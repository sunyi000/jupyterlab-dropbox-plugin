{"version":3,"file":"registry.js","sourceRoot":"","sources":["../../../../rendermime/src/registry.ts"],"names":[],"mappings":"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","sourcesContent":["/*-----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { Contents, Session } from '@jupyterlab/services';\n\nimport { IRenderMime } from '@jupyterlab/rendermime-interfaces';\n\nimport { PathExt, URLExt } from '@jupyterlab/coreutils';\n\nimport {\n  IClientSession,\n  ISanitizer,\n  defaultSanitizer\n} from '@jupyterlab/apputils';\n\nimport { ReadonlyJSONObject, Token } from '@phosphor/coreutils';\n\nimport { MimeModel } from './mimemodel';\n\n/* tslint:disable */\n/**\n * The rendermime token.\n */\nexport const IRenderMimeRegistry = new Token<IRenderMimeRegistry>(\n  '@jupyterlab/rendermime:IRenderMimeRegistry'\n);\n\nexport interface IRenderMimeRegistry extends RenderMimeRegistry {}\n/* tslint:enable */\n\n/* tslint:disable */\n/**\n * The latex typesetter token.\n */\nexport const ILatexTypesetter = new Token<IRenderMime.ILatexTypesetter>(\n  '@jupyterlab/rendermime:ILatexTypesetter'\n);\n\nexport interface ILatexTypesetter extends IRenderMime.ILatexTypesetter {}\n/* tslint:enable */\n\n/**\n * An object which manages mime renderer factories.\n *\n * This object is used to render mime models using registered mime\n * renderers, selecting the preferred mime renderer to render the\n * model into a widget.\n *\n * #### Notes\n * This class is not intended to be subclassed.\n */\nexport class RenderMimeRegistry {\n  /**\n   * Construct a new rendermime.\n   *\n   * @param options - The options for initializing the instance.\n   */\n  constructor(options: RenderMimeRegistry.IOptions = {}) {\n    // Parse the options.\n    this.resolver = options.resolver || null;\n    this.linkHandler = options.linkHandler || null;\n    this.latexTypesetter = options.latexTypesetter || null;\n    this.sanitizer = options.sanitizer || defaultSanitizer;\n\n    // Add the initial factories.\n    if (options.initialFactories) {\n      for (let factory of options.initialFactories) {\n        this.addFactory(factory);\n      }\n    }\n  }\n\n  /**\n   * The sanitizer used by the rendermime instance.\n   */\n  readonly sanitizer: ISanitizer;\n\n  /**\n   * The object used to resolve relative urls for the rendermime instance.\n   */\n  readonly resolver: IRenderMime.IResolver | null;\n\n  /**\n   * The object used to handle path opening links.\n   */\n  readonly linkHandler: IRenderMime.ILinkHandler | null;\n\n  /**\n   * The LaTeX typesetter for the rendermime.\n   */\n  readonly latexTypesetter: IRenderMime.ILatexTypesetter | null;\n\n  /**\n   * The ordered list of mimeTypes.\n   */\n  get mimeTypes(): ReadonlyArray<string> {\n    return this._types || (this._types = Private.sortedTypes(this._ranks));\n  }\n\n  /**\n   * Find the preferred mime type for a mime bundle.\n   *\n   * @param bundle - The bundle of mime data.\n   *\n   * @param safe - How to consider safe/unsafe factories. If 'ensure',\n   *   it will only consider safe factories. If 'any', any factory will be\n   *   considered. If 'prefer', unsafe factories will be considered, but\n   *   only after the safe options have been exhausted.\n   *\n   * @returns The preferred mime type from the available factories,\n   *   or `undefined` if the mime type cannot be rendered.\n   */\n  preferredMimeType(\n    bundle: ReadonlyJSONObject,\n    safe: 'ensure' | 'prefer' | 'any' = 'ensure'\n  ): string | undefined {\n    // Try to find a safe factory first, if preferred.\n    if (safe === 'ensure' || safe === 'prefer') {\n      for (let mt of this.mimeTypes) {\n        if (mt in bundle && this._factories[mt].safe) {\n          return mt;\n        }\n      }\n    }\n\n    if (safe !== 'ensure') {\n      // Otherwise, search for the best factory among all factories.\n      for (let mt of this.mimeTypes) {\n        if (mt in bundle) {\n          return mt;\n        }\n      }\n    }\n\n    // Otherwise, no matching mime type exists.\n    return undefined;\n  }\n\n  /**\n   * Create a renderer for a mime type.\n   *\n   * @param mimeType - The mime type of interest.\n   *\n   * @returns A new renderer for the given mime type.\n   *\n   * @throws An error if no factory exists for the mime type.\n   */\n  createRenderer(mimeType: string): IRenderMime.IRenderer {\n    // Throw an error if no factory exists for the mime type.\n    if (!(mimeType in this._factories)) {\n      throw new Error(`No factory for mime type: '${mimeType}'`);\n    }\n\n    // Invoke the best factory for the given mime type.\n    return this._factories[mimeType].createRenderer({\n      mimeType,\n      resolver: this.resolver,\n      sanitizer: this.sanitizer,\n      linkHandler: this.linkHandler,\n      latexTypesetter: this.latexTypesetter\n    });\n  }\n\n  /**\n   * Create a new mime model.  This is a convenience method.\n   *\n   * @options - The options used to create the model.\n   *\n   * @returns A new mime model.\n   */\n  createModel(options: MimeModel.IOptions = {}): MimeModel {\n    return new MimeModel(options);\n  }\n\n  /**\n   * Create a clone of this rendermime instance.\n   *\n   * @param options - The options for configuring the clone.\n   *\n   * @returns A new independent clone of the rendermime.\n   */\n  clone(options: RenderMimeRegistry.ICloneOptions = {}): RenderMimeRegistry {\n    // Create the clone.\n    let clone = new RenderMimeRegistry({\n      resolver: options.resolver || this.resolver || undefined,\n      sanitizer: options.sanitizer || this.sanitizer || undefined,\n      linkHandler: options.linkHandler || this.linkHandler || undefined,\n      latexTypesetter: options.latexTypesetter || this.latexTypesetter\n    });\n\n    // Clone the internal state.\n    clone._factories = { ...this._factories };\n    clone._ranks = { ...this._ranks };\n    clone._id = this._id;\n\n    // Return the cloned object.\n    return clone;\n  }\n\n  /**\n   * Get the renderer factory registered for a mime type.\n   *\n   * @param mimeType - The mime type of interest.\n   *\n   * @returns The factory for the mime type, or `undefined`.\n   */\n  getFactory(mimeType: string): IRenderMime.IRendererFactory | undefined {\n    return this._factories[mimeType];\n  }\n\n  /**\n   * Add a renderer factory to the rendermime.\n   *\n   * @param factory - The renderer factory of interest.\n   *\n   * @param rank - The rank of the renderer. A lower rank indicates\n   *   a higher priority for rendering. If not given, the rank will\n   *   defer to the `defaultRank` of the factory.  If no `defaultRank`\n   *   is given, it will default to 100.\n   *\n   * #### Notes\n   * The renderer will replace an existing renderer for the given\n   * mimeType.\n   */\n  addFactory(factory: IRenderMime.IRendererFactory, rank?: number): void {\n    if (rank === undefined) {\n      rank = factory.defaultRank;\n      if (rank === undefined) {\n        rank = 100;\n      }\n    }\n    for (let mt of factory.mimeTypes) {\n      this._factories[mt] = factory;\n      this._ranks[mt] = { rank, id: this._id++ };\n    }\n    this._types = null;\n  }\n\n  /**\n   * Remove a mime type.\n   *\n   * @param mimeType - The mime type of interest.\n   */\n  removeMimeType(mimeType: string): void {\n    delete this._factories[mimeType];\n    delete this._ranks[mimeType];\n    this._types = null;\n  }\n\n  /**\n   * Get the rank for a given mime type.\n   *\n   * @param mimeType - The mime type of interest.\n   *\n   * @returns The rank of the mime type or undefined.\n   */\n  getRank(mimeType: string): number | undefined {\n    let rank = this._ranks[mimeType];\n    return rank && rank.rank;\n  }\n\n  /**\n   * Set the rank of a given mime type.\n   *\n   * @param mimeType - The mime type of interest.\n   *\n   * @param rank - The new rank to assign.\n   *\n   * #### Notes\n   * This is a no-op if the mime type is not registered.\n   */\n  setRank(mimeType: string, rank: number): void {\n    if (!this._ranks[mimeType]) {\n      return;\n    }\n    let id = this._id++;\n    this._ranks[mimeType] = { rank, id };\n    this._types = null;\n  }\n\n  private _id = 0;\n  private _ranks: Private.RankMap = {};\n  private _types: string[] | null = null;\n  private _factories: Private.FactoryMap = {};\n}\n\n/**\n * The namespace for `RenderMimeRegistry` class statics.\n */\nexport namespace RenderMimeRegistry {\n  /**\n   * The options used to initialize a rendermime instance.\n   */\n  export interface IOptions {\n    /**\n     * Initial factories to add to the rendermime instance.\n     */\n    initialFactories?: ReadonlyArray<IRenderMime.IRendererFactory>;\n\n    /**\n     * The sanitizer used to sanitize untrusted html inputs.\n     *\n     * If not given, a default sanitizer will be used.\n     */\n    sanitizer?: IRenderMime.ISanitizer;\n\n    /**\n     * The initial resolver object.\n     *\n     * The default is `null`.\n     */\n    resolver?: IRenderMime.IResolver;\n\n    /**\n     * An optional path handler.\n     */\n    linkHandler?: IRenderMime.ILinkHandler;\n\n    /**\n     * An optional LaTeX typesetter.\n     */\n    latexTypesetter?: IRenderMime.ILatexTypesetter;\n  }\n\n  /**\n   * The options used to clone a rendermime instance.\n   */\n  export interface ICloneOptions {\n    /**\n     * The new sanitizer used to sanitize untrusted html inputs.\n     */\n    sanitizer?: IRenderMime.ISanitizer;\n\n    /**\n     * The new resolver object.\n     */\n    resolver?: IRenderMime.IResolver;\n\n    /**\n     * The new path handler.\n     */\n    linkHandler?: IRenderMime.ILinkHandler;\n\n    /**\n     * The new LaTeX typesetter.\n     */\n    latexTypesetter?: IRenderMime.ILatexTypesetter;\n  }\n\n  /**\n   * A default resolver that uses a session and a contents manager.\n   */\n  export class UrlResolver implements IRenderMime.IResolver {\n    /**\n     * Create a new url resolver for a console.\n     */\n    constructor(options: IUrlResolverOptions) {\n      this._session = options.session;\n      this._contents = options.contents;\n    }\n\n    /**\n     * Resolve a relative url to a correct server path.\n     */\n    resolveUrl(url: string): Promise<string> {\n      if (this.isLocal(url)) {\n        let cwd = PathExt.dirname(this._session.path);\n        url = PathExt.resolve(cwd, url);\n      }\n      return Promise.resolve(url);\n    }\n\n    /**\n     * Get the download url of a given absolute server path.\n     */\n    getDownloadUrl(path: string): Promise<string> {\n      if (this.isLocal(path)) {\n        return this._contents.getDownloadUrl(path);\n      }\n      return Promise.resolve(path);\n    }\n\n    /**\n     * Whether the URL should be handled by the resolver\n     * or not.\n     *\n     * #### Notes\n     * This is similar to the `isLocal` check in `URLExt`,\n     * but it also checks whether the path points to any\n     * of the `IDrive`s that may be registered with the contents\n     * manager.\n     */\n    isLocal(url: string): boolean {\n      return URLExt.isLocal(url) || !!this._contents.driveName(url);\n    }\n\n    private _session: Session.ISession | IClientSession;\n    private _contents: Contents.IManager;\n  }\n\n  /**\n   * The options used to create a UrlResolver.\n   */\n  export interface IUrlResolverOptions {\n    /**\n     * The session used by the resolver.\n     */\n    session: Session.ISession | IClientSession;\n\n    /**\n     * The contents manager used by the resolver.\n     */\n    contents: Contents.IManager;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A type alias for a mime rank and tie-breaking id.\n   */\n  export type RankPair = { readonly id: number; readonly rank: number };\n\n  /**\n   * A type alias for a mapping of mime type -> rank pair.\n   */\n  export type RankMap = { [key: string]: RankPair };\n\n  /**\n   * A type alias for a mapping of mime type -> ordered factories.\n   */\n  export type FactoryMap = { [key: string]: IRenderMime.IRendererFactory };\n\n  /**\n   * Get the mime types in the map, ordered by rank.\n   */\n  export function sortedTypes(map: RankMap): string[] {\n    return Object.keys(map).sort((a, b) => {\n      let p1 = map[a];\n      let p2 = map[b];\n      if (p1.rank !== p2.rank) {\n        return p1.rank - p2.rank;\n      }\n      return p1.id - p2.id;\n    });\n  }\n}\n"]}