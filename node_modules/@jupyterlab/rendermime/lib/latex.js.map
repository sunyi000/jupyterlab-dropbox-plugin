{"version":3,"file":"latex.js","sourceRoot":"","sources":["../../../../rendermime/src/latex.ts"],"names":[],"mappings":"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","sourcesContent":["/*-----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n// Some magic for deferring mathematical expressions to MathJax\n// by hiding them from the Markdown parser.\n// Some of the code here is adapted with permission from Davide Cervone\n// under the terms of the Apache2 license governing the MathJax project.\n// Other minor modifications are also due to StackExchange and are used with\n// permission.\n\nconst inline = '$'; // the inline math delimiter\n\n// MATHSPLIT contains the pattern for math delimiters and special symbols\n// needed for searching for math in the text input.\nconst MATHSPLIT = /(\\$\\$?|\\\\(?:begin|end)\\{[a-z]*\\*?\\}|\\\\[{}$]|[{}]|(?:\\n\\s*)+|@@\\d+@@|\\\\\\\\(?:\\(|\\)|\\[|\\]))/i;\n\n/**\n *  Break up the text into its component parts and search\n *    through them for math delimiters, braces, linebreaks, etc.\n *  Math delimiters must match and braces must balance.\n *  Don't allow math to pass through a double linebreak\n *    (which will be a paragraph).\n */\nexport function removeMath(text: string): { text: string; math: string[] } {\n  let math: string[] = []; // stores math strings for later\n  let start: number | null = null;\n  let end: string | null = null;\n  let last: number | null = null;\n  let braces: number = 0;\n  let deTilde: (text: string) => string;\n\n  // Except for extreme edge cases, this should catch precisely those pieces of the markdown\n  // source that will later be turned into code spans. While MathJax will not TeXify code spans,\n  // we still have to consider them at this point; the following issue has happened several times:\n  //\n  //     `$foo` and `$bar` are variables.  -->  <code>$foo ` and `$bar</code> are variables.\n  let hasCodeSpans = /`/.test(text);\n  if (hasCodeSpans) {\n    text = text\n      .replace(/~/g, '~T')\n      .replace(/(^|[^\\\\])(`+)([^\\n]*?[^`\\n])\\2(?!`)/gm, wholematch =>\n        wholematch.replace(/\\$/g, '~D')\n      );\n    deTilde = (text: string) => {\n      return text.replace(\n        /~([TD])/g,\n        (wholematch, character) => (character === 'T' ? '~' : inline)\n      );\n    };\n  } else {\n    deTilde = (text: string) => {\n      return text;\n    };\n  }\n\n  let blocks = text.replace(/\\r\\n?/g, '\\n').split(MATHSPLIT);\n\n  for (let i = 1, m = blocks.length; i < m; i += 2) {\n    let block = blocks[i];\n    if (block.charAt(0) === '@') {\n      //\n      //  Things that look like our math markers will get\n      //  stored and then retrieved along with the math.\n      //\n      blocks[i] = '@@' + math.length + '@@';\n      math.push(block);\n    } else if (start !== null) {\n      //\n      //  If we are in math, look for the end delimiter,\n      //    but don't go past double line breaks, and\n      //    and balance braces within the math.\n      //\n      if (block === end) {\n        if (braces) {\n          last = i;\n        } else {\n          blocks = processMath(start, i, deTilde, math, blocks);\n          start = null;\n          end = null;\n          last = null;\n        }\n      } else if (block.match(/\\n.*\\n/)) {\n        if (last !== null) {\n          i = last;\n          blocks = processMath(start, i, deTilde, math, blocks);\n        }\n        start = null;\n        end = null;\n        last = null;\n        braces = 0;\n      } else if (block === '{') {\n        braces++;\n      } else if (block === '}' && braces) {\n        braces--;\n      }\n    } else {\n      //\n      //  Look for math start delimiters and when\n      //    found, set up the end delimiter.\n      //\n      if (block === inline || block === '$$') {\n        start = i;\n        end = block;\n        braces = 0;\n      } else if (block === '\\\\\\\\(' || block === '\\\\\\\\[') {\n        start = i;\n        end = block.slice(-1) === '(' ? '\\\\\\\\)' : '\\\\\\\\]';\n        braces = 0;\n      } else if (block.substr(1, 5) === 'begin') {\n        start = i;\n        end = '\\\\end' + block.substr(6);\n        braces = 0;\n      }\n    }\n  }\n  if (start !== null && last !== null) {\n    blocks = processMath(start, last, deTilde, math, blocks);\n    start = null;\n    end = null;\n    last = null;\n  }\n  return { text: deTilde(blocks.join('')), math };\n}\n\n/**\n * Put back the math strings that were saved,\n * and clear the math array (no need to keep it around).\n */\nexport function replaceMath(text: string, math: string[]): string {\n  /**\n   * Replace a math placeholder with its corresponding group.\n   * The math delimiters \"\\\\(\", \"\\\\[\", \"\\\\)\" and \"\\\\]\" are replaced\n   * removing one backslash in order to be interpreted correctly by MathJax.\n   */\n  let process = (match: string, n: number): string => {\n    let group = math[n];\n    if (\n      group.substr(0, 3) === '\\\\\\\\(' &&\n      group.substr(group.length - 3) === '\\\\\\\\)'\n    ) {\n      group = '\\\\(' + group.substring(3, group.length - 3) + '\\\\)';\n    } else if (\n      group.substr(0, 3) === '\\\\\\\\[' &&\n      group.substr(group.length - 3) === '\\\\\\\\]'\n    ) {\n      group = '\\\\[' + group.substring(3, group.length - 3) + '\\\\]';\n    }\n    return group;\n  };\n  // Replace all the math group placeholders in the text\n  // with the saved strings.\n  return text.replace(/@@(\\d+)@@/g, process);\n}\n\n/**\n * Process math blocks.\n *\n * The math is in blocks i through j, so\n *   collect it into one block and clear the others.\n *  Replace &, <, and > by named entities.\n *  For IE, put <br> at the ends of comments since IE removes \\n.\n *  Clear the current math positions and store the index of the\n *   math, then push the math string onto the storage array.\n *  The preProcess function is called on all blocks if it has been passed in\n */\nfunction processMath(\n  i: number,\n  j: number,\n  preProcess: (input: string) => string,\n  math: string[],\n  blocks: string[]\n): string[] {\n  let block = blocks\n    .slice(i, j + 1)\n    .join('')\n    .replace(/&/g, '&amp;') // use HTML entity for &\n    .replace(/</g, '&lt;') // use HTML entity for <\n    .replace(/>/g, '&gt;'); // use HTML entity for >\n  if (navigator && navigator.appName === 'Microsoft Internet Explorer') {\n    block = block.replace(/(%[^\\n]*)\\n/g, '$1<br/>\\n');\n  }\n  while (j > i) {\n    blocks[j] = '';\n    j--;\n  }\n  blocks[i] = '@@' + math.length + '@@'; // replace the current block text with a unique tag to find later\n  if (preProcess) {\n    block = preProcess(block);\n  }\n  math.push(block);\n  return blocks;\n}\n"]}