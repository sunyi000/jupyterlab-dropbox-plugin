{"version":3,"file":"text.js","sourceRoot":"","sources":["../../../../coreutils/src/text.ts"],"names":[],"mappings":";AAAA,0CAA0C;AAC1C,2DAA2D;;AAE3D;;GAEG;AACH,IAAiB,IAAI,CAkEpB;AAlED,WAAiB,IAAI;IACnB,uEAAuE;IACvE,+DAA+D;IAC/D,qDAAqD;IACrD,0EAA0E;IAC1E,wDAAwD;IAExD,MAAM,cAAc,GAAY,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;IAEhD;;;;;;;;OAQG;IACH,4BAAmC,KAAa,EAAE,IAAY;QAC5D,IAAI,cAAc,EAAE;YAClB,sCAAsC;YACtC,OAAO,KAAK,CAAC;SACd;QACD,IAAI,OAAO,GAAG,KAAK,CAAC;QACpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;YACrD,IAAI,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAClC,2BAA2B;YAC3B,IAAI,QAAQ,IAAI,MAAM,IAAI,QAAQ,IAAI,MAAM,EAAE;gBAC5C,IAAI,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC1C,IAAI,YAAY,IAAI,MAAM,IAAI,YAAY,IAAI,MAAM,EAAE;oBACpD,OAAO,EAAE,CAAC;oBACV,CAAC,EAAE,CAAC;iBACL;aACF;SACF;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IAlBe,uBAAkB,qBAkBjC,CAAA;IAED;;;;;;;;OAQG;IACH,4BAAmC,OAAe,EAAE,IAAY;QAC9D,IAAI,cAAc,EAAE;YAClB,sCAAsC;YACtC,OAAO,OAAO,CAAC;SAChB;QACD,IAAI,KAAK,GAAG,OAAO,CAAC;QACpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;YACrD,IAAI,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAClC,2BAA2B;YAC3B,IAAI,QAAQ,IAAI,MAAM,IAAI,QAAQ,IAAI,MAAM,EAAE;gBAC5C,IAAI,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC1C,IAAI,YAAY,IAAI,MAAM,IAAI,YAAY,IAAI,MAAM,EAAE;oBACpD,KAAK,EAAE,CAAC;oBACR,CAAC,EAAE,CAAC;iBACL;aACF;SACF;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAlBe,uBAAkB,qBAkBjC,CAAA;AACH,CAAC,EAlEgB,IAAI,GAAJ,YAAI,KAAJ,YAAI,QAkEpB","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n/**\n * The namespace for text-related functions.\n */\nexport namespace Text {\n  // javascript stores text as utf16 and string indices use \"code units\",\n  // which stores high-codepoint characters as \"surrogate pairs\",\n  // which occupy two indices in the javascript string.\n  // We need to translate cursor_pos in the Jupyter protocol (in characters)\n  // to js offset (with surrogate pairs taking two spots).\n\n  const HAS_SURROGATES: boolean = '𝐚'.length > 1;\n\n  /**\n   * Convert a javascript string index into a unicode character offset\n   *\n   * @param jsIdx - The javascript string index (counting surrogate pairs)\n   *\n   * @param text - The text in which the offset is calculated\n   *\n   * @returns The unicode character offset\n   */\n  export function jsIndexToCharIndex(jsIdx: number, text: string): number {\n    if (HAS_SURROGATES) {\n      // not using surrogates, nothing to do\n      return jsIdx;\n    }\n    let charIdx = jsIdx;\n    for (let i = 0; i + 1 < text.length && i < jsIdx; i++) {\n      let charCode = text.charCodeAt(i);\n      // check for surrogate pair\n      if (charCode >= 0xd800 && charCode <= 0xdbff) {\n        let nextCharCode = text.charCodeAt(i + 1);\n        if (nextCharCode >= 0xdc00 && nextCharCode <= 0xdfff) {\n          charIdx--;\n          i++;\n        }\n      }\n    }\n    return charIdx;\n  }\n\n  /**\n   * Convert a unicode character offset to a javascript string index.\n   *\n   * @param charIdx - The index in unicode characters\n   *\n   * @param text - The text in which the offset is calculated\n   *\n   * @returns The js-native index\n   */\n  export function charIndexToJsIndex(charIdx: number, text: string): number {\n    if (HAS_SURROGATES) {\n      // not using surrogates, nothing to do\n      return charIdx;\n    }\n    let jsIdx = charIdx;\n    for (let i = 0; i + 1 < text.length && i < jsIdx; i++) {\n      let charCode = text.charCodeAt(i);\n      // check for surrogate pair\n      if (charCode >= 0xd800 && charCode <= 0xdbff) {\n        let nextCharCode = text.charCodeAt(i + 1);\n        if (nextCharCode >= 0xdc00 && nextCharCode <= 0xdfff) {\n          jsIdx++;\n          i++;\n        }\n      }\n    }\n    return jsIdx;\n  }\n}\n"]}