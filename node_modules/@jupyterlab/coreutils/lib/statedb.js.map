{"version":3,"file":"statedb.js","sourceRoot":"","sources":["../../../../coreutils/src/statedb.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport {\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n  Token\n} from '@phosphor/coreutils';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { IDataConnector } from './interfaces';\n\n/* tslint:disable */\n/**\n * The default state database token.\n */\nexport const IStateDB = new Token<IStateDB>('@jupyterlab/coreutils:IStateDB');\n/* tslint:enable */\n\n/**\n * An object which holds an id/value pair.\n */\nexport interface IStateItem {\n  /**\n   * The identifier key for a state item.\n   */\n  id: string;\n\n  /**\n   * The data value for a state item.\n   */\n  value: ReadonlyJSONValue;\n}\n\n/**\n * The description of a state database.\n */\nexport interface IStateDB extends IDataConnector<ReadonlyJSONValue> {\n  /**\n   * The maximum allowed length of the data after it has been serialized.\n   */\n  readonly maxLength: number;\n\n  /**\n   * The namespace prefix for all state database entries.\n   *\n   * #### Notes\n   * This value should be set at instantiation and will only be used\n   * internally by a state database. That means, for example, that an\n   * app could have multiple, mutually exclusive state databases.\n   */\n  readonly namespace: string;\n\n  /**\n   * Retrieve all the saved bundles for a namespace.\n   *\n   * @param namespace - The namespace to retrieve.\n   *\n   * @returns A promise that bears a collection data payloads for a namespace.\n   *\n   * #### Notes\n   * Namespaces are entirely conventional entities. The `id` values of stored\n   * items in the state database are formatted: `'namespace:identifier'`, which\n   * is the same convention that command identifiers in JupyterLab use as well.\n   *\n   * If there are any errors in retrieving the data, they will be logged to the\n   * console in order to optimistically return any extant data without failing.\n   * This promise will always succeed.\n   */\n  fetchNamespace(namespace: string): Promise<IStateItem[]>;\n\n  /**\n   * Return a serialized copy of the state database's entire contents.\n   *\n   * @returns A promise that bears the database contents as JSON.\n   */\n  toJSON(): Promise<ReadonlyJSONObject>;\n}\n\n/**\n * The default concrete implementation of a state database.\n */\nexport class StateDB implements IStateDB {\n  /**\n   * Create a new state database.\n   *\n   * @param options - The instantiation options for a state database.\n   */\n  constructor(options: StateDB.IOptions) {\n    const { namespace, transform, windowName } = options;\n\n    this.namespace = namespace;\n\n    this._window = windowName || '';\n    this._ready = (transform || Promise.resolve(null)).then(transformation => {\n      if (!transformation) {\n        return;\n      }\n\n      const { contents, type } = transformation;\n\n      switch (type) {\n        case 'cancel':\n          return;\n        case 'clear':\n          this._clear();\n          return;\n        case 'merge':\n          this._merge(contents || {});\n          return;\n        case 'overwrite':\n          this._overwrite(contents || {});\n          return;\n        default:\n          return;\n      }\n    });\n  }\n\n  get changed(): ISignal<this, StateDB.Change> {\n    return this._changed;\n  }\n\n  /**\n   * The maximum allowed length of the data after it has been serialized.\n   */\n  readonly maxLength = 2000;\n\n  /**\n   * The namespace prefix for all state database entries.\n   *\n   * #### Notes\n   * This value should be set at instantiation and will only be used internally\n   * by a state database. That means, for example, that an app could have\n   * multiple, mutually exclusive state databases.\n   */\n  readonly namespace: string;\n\n  /**\n   * Clear the entire database.\n   */\n  clear(silent = false): Promise<void> {\n    return this._ready.then(() => {\n      this._clear();\n\n      if (silent) {\n        return;\n      }\n\n      this._changed.emit({ id: null, type: 'clear' });\n    });\n  }\n\n  /**\n   * Retrieve a saved bundle from the database.\n   *\n   * @param id - The identifier used to retrieve a data bundle.\n   *\n   * @returns A promise that bears a data payload if available.\n   *\n   * #### Notes\n   * The `id` values of stored items in the state database are formatted:\n   * `'namespace:identifier'`, which is the same convention that command\n   * identifiers in JupyterLab use as well. While this is not a technical\n   * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for\n   * using the `fetchNamespace()` method.\n   *\n   * The promise returned by this method may be rejected if an error occurs in\n   * retrieving the data. Non-existence of an `id` will succeed with `null`.\n   */\n  fetch(id: string): Promise<ReadonlyJSONValue | undefined> {\n    return this._ready.then(() => this._fetch(id));\n  }\n\n  /**\n   * Retrieve all the saved bundles for a namespace.\n   *\n   * @param namespace - The namespace to retrieve.\n   *\n   * @returns A promise that bears a collection of payloads for a namespace.\n   *\n   * #### Notes\n   * Namespaces are entirely conventional entities. The `id` values of stored\n   * items in the state database are formatted: `'namespace:identifier'`, which\n   * is the same convention that command identifiers in JupyterLab use as well.\n   *\n   * If there are any errors in retrieving the data, they will be logged to the\n   * console in order to optimistically return any extant data without failing.\n   * This promise will always succeed.\n   */\n  fetchNamespace(namespace: string): Promise<IStateItem[]> {\n    return this._ready.then(() => {\n      const prefix = `${this._window}:${this.namespace}:`;\n      const mask = (key: string) => key.replace(prefix, '');\n\n      return StateDB.fetchNamespace(`${prefix}${namespace}:`, mask);\n    });\n  }\n\n  /**\n   * Remove a value from the database.\n   *\n   * @param id - The identifier for the data being removed.\n   *\n   * @returns A promise that is rejected if remove fails and succeeds otherwise.\n   */\n  remove(id: string): Promise<void> {\n    return this._ready.then(() => {\n      this._remove(id);\n      this._changed.emit({ id, type: 'remove' });\n    });\n  }\n\n  /**\n   * Save a value in the database.\n   *\n   * @param id - The identifier for the data being saved.\n   *\n   * @param value - The data being saved.\n   *\n   * @returns A promise that is rejected if saving fails and succeeds otherwise.\n   *\n   * #### Notes\n   * The `id` values of stored items in the state database are formatted:\n   * `'namespace:identifier'`, which is the same convention that command\n   * identifiers in JupyterLab use as well. While this is not a technical\n   * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for\n   * using the `fetchNamespace()` method.\n   */\n  save(id: string, value: ReadonlyJSONValue): Promise<void> {\n    return this._ready.then(() => {\n      this._save(id, value);\n      this._changed.emit({ id, type: 'save' });\n    });\n  }\n\n  /**\n   * Return a serialized copy of the state database's entire contents.\n   *\n   * @returns A promise that bears the database contents as JSON.\n   */\n  toJSON(): Promise<ReadonlyJSONObject> {\n    return this._ready.then(() => {\n      const prefix = `${this._window}:${this.namespace}:`;\n      const mask = (key: string) => key.replace(prefix, '');\n\n      return StateDB.toJSON(prefix, mask);\n    });\n  }\n\n  /**\n   * Clear the entire database.\n   *\n   * #### Notes\n   * Unlike the public `clear` method, this method is synchronous.\n   */\n  private _clear(): void {\n    const { localStorage } = window;\n    const prefix = `${this._window}:${this.namespace}:`;\n    let i = localStorage.length;\n\n    while (i) {\n      let key = localStorage.key(--i);\n\n      if (key && key.indexOf(prefix) === 0) {\n        localStorage.removeItem(key);\n      }\n    }\n  }\n\n  /**\n   * Fetch a value from the database.\n   *\n   * #### Notes\n   * Unlike the public `fetch` method, this method is synchronous.\n   */\n  private _fetch(id: string): ReadonlyJSONValue | undefined {\n    const key = `${this._window}:${this.namespace}:${id}`;\n    const value = window.localStorage.getItem(key);\n\n    if (value) {\n      const envelope = JSON.parse(value) as Private.Envelope;\n\n      return envelope.v;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Merge data into the state database.\n   */\n  private _merge(contents: ReadonlyJSONObject): void {\n    Object.keys(contents).forEach(key => {\n      this._save(key, contents[key]);\n    });\n  }\n\n  /**\n   * Overwrite the entire database with new contents.\n   */\n  private _overwrite(contents: ReadonlyJSONObject): void {\n    this._clear();\n    this._merge(contents);\n  }\n\n  /**\n   * Remove a key in the database.\n   *\n   * #### Notes\n   * Unlike the public `remove` method, this method is synchronous.\n   */\n  private _remove(id: string): void {\n    const key = `${this._window}:${this.namespace}:${id}`;\n\n    window.localStorage.removeItem(key);\n  }\n\n  /**\n   * Save a key and its value in the database.\n   *\n   * #### Notes\n   * Unlike the public `save` method, this method is synchronous.\n   */\n  private _save(id: string, value: ReadonlyJSONValue): void {\n    const key = `${this._window}:${this.namespace}:${id}`;\n    const envelope: Private.Envelope = { v: value };\n    const serialized = JSON.stringify(envelope);\n    const length = serialized.length;\n    const max = this.maxLength;\n\n    if (length > max) {\n      throw new Error(`Data length (${length}) exceeds maximum (${max})`);\n    }\n\n    window.localStorage.setItem(key, serialized);\n  }\n\n  private _changed = new Signal<this, StateDB.Change>(this);\n  private _ready: Promise<void>;\n  private _window: string;\n}\n\n/**\n * A namespace for StateDB statics.\n */\nexport namespace StateDB {\n  /**\n   * A state database change.\n   */\n  export type Change = {\n    /**\n     * The key of the database item that was changed.\n     *\n     * #### Notes\n     * This field is set to `null` for global changes (i.e. `clear`).\n     */\n    id: string | null;\n\n    /**\n     * The type of change.\n     */\n    type: 'clear' | 'remove' | 'save';\n  };\n\n  /**\n   * A data transformation that can be applied to a state database.\n   */\n  export type DataTransform = {\n    /*\n     * The change operation being applied.\n     */\n    type: 'cancel' | 'clear' | 'merge' | 'overwrite';\n\n    /**\n     * The contents of the change operation.\n     */\n    contents: ReadonlyJSONObject | null;\n  };\n\n  /**\n   * The instantiation options for a state database.\n   */\n  export interface IOptions {\n    /**\n     * The namespace prefix for all state database entries.\n     */\n    namespace: string;\n\n    /**\n     * An optional promise that resolves with a data transformation that is\n     * applied to the database contents before the database begins resolving\n     * client requests.\n     */\n    transform?: Promise<DataTransform>;\n\n    /**\n     * An optional name for the application window.\n     *\n     * #### Notes\n     * In environments where multiple windows can instantiate a state database,\n     * a window name is necessary to prefix all keys that are stored within the\n     * local storage that is shared by all windows. In JupyterLab, this window\n     * name is generated by the `IWindowResolver` extension.\n     */\n    windowName?: string;\n  }\n\n  /**\n   * Retrieve all the saved bundles for a given namespace in local storage.\n   *\n   * @param prefix - The namespace to retrieve.\n   *\n   * @param mask - Optional mask function to transform each key retrieved.\n   *\n   * @returns A collection of data payloads for a given prefix.\n   *\n   * #### Notes\n   * If there are any errors in retrieving the data, they will be logged to the\n   * console in order to optimistically return any extant data without failing.\n   */\n  export function fetchNamespace(\n    namespace: string,\n    mask: (key: string) => string = key => key\n  ): IStateItem[] {\n    const { localStorage } = window;\n\n    let items: IStateItem[] = [];\n    let i = localStorage.length;\n\n    while (i) {\n      let key = localStorage.key(--i);\n\n      if (key && key.indexOf(namespace) === 0) {\n        let value = localStorage.getItem(key);\n\n        try {\n          let envelope = JSON.parse(value) as Private.Envelope;\n\n          items.push({\n            id: mask(key),\n            value: envelope ? envelope.v : undefined\n          });\n        } catch (error) {\n          console.warn(error);\n          localStorage.removeItem(key);\n        }\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * Return a serialized copy of a namespace's contents from local storage.\n   *\n   * @returns The namespace contents as JSON.\n   */\n  export function toJSON(\n    namespace: string,\n    mask: (key: string) => string = key => key\n  ): ReadonlyJSONObject {\n    return fetchNamespace(namespace, mask).reduce(\n      (acc, val) => {\n        acc[val.id] = val.value;\n        return acc;\n      },\n      {} as Partial<ReadonlyJSONObject>\n    );\n  }\n}\n\n/*\n * A namespace for private module data.\n */\nnamespace Private {\n  /**\n   * An envelope around a JSON value stored in the state database.\n   */\n  export type Envelope = { readonly v: ReadonlyJSONValue };\n}\n"]}