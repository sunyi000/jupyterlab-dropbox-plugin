{"version":3,"file":"manager.js","sourceRoot":"","sources":["../../../../docmanager/src/manager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { IClientSession } from '@jupyterlab/apputils';\n\nimport { PathExt } from '@jupyterlab/coreutils';\n\nimport { UUID } from '@phosphor/coreutils';\n\nimport {\n  DocumentRegistry,\n  Context,\n  IDocumentWidget\n} from '@jupyterlab/docregistry';\n\nimport { Contents, Kernel, ServiceManager } from '@jupyterlab/services';\n\nimport { ArrayExt, find } from '@phosphor/algorithm';\n\nimport { Token } from '@phosphor/coreutils';\n\nimport { IDisposable } from '@phosphor/disposable';\n\nimport { AttachedProperty } from '@phosphor/properties';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { Widget } from '@phosphor/widgets';\n\nimport { SaveHandler } from './savehandler';\n\nimport { DocumentWidgetManager } from './widgetmanager';\n\n/* tslint:disable */\n/**\n * The document registry token.\n */\nexport const IDocumentManager = new Token<IDocumentManager>(\n  '@jupyterlab/docmanager:IDocumentManager'\n);\n/* tslint:enable */\n\n/**\n * The interface for a document manager.\n */\nexport interface IDocumentManager extends DocumentManager {}\n\n/**\n * The document manager.\n *\n * #### Notes\n * The document manager is used to register model and widget creators,\n * and the file browser uses the document manager to create widgets. The\n * document manager maintains a context for each path and model type that is\n * open, and a list of widgets for each context. The document manager is in\n * control of the proper closing and disposal of the widgets and contexts.\n */\nexport class DocumentManager implements IDisposable {\n  /**\n   * Construct a new document manager.\n   */\n  constructor(options: DocumentManager.IOptions) {\n    this.registry = options.registry;\n    this.services = options.manager;\n\n    this._opener = options.opener;\n    this._when = options.when || options.manager.ready;\n\n    let widgetManager = new DocumentWidgetManager({ registry: this.registry });\n    widgetManager.activateRequested.connect(this._onActivateRequested, this);\n    this._widgetManager = widgetManager;\n    this._setBusy = options.setBusy;\n  }\n\n  /**\n   * The registry used by the manager.\n   */\n  readonly registry: DocumentRegistry;\n\n  /**\n   * The service manager used by the manager.\n   */\n  readonly services: ServiceManager.IManager;\n\n  /**\n   * A signal emitted when one of the documents is activated.\n   */\n  get activateRequested(): ISignal<this, string> {\n    return this._activateRequested;\n  }\n\n  /**\n   * Whether to autosave documents.\n   */\n  get autosave(): boolean {\n    return this._autosave;\n  }\n  set autosave(value: boolean) {\n    this._autosave = value;\n\n    // For each existing context, start/stop the autosave handler as needed.\n    this._contexts.forEach(context => {\n      const handler = Private.saveHandlerProperty.get(context);\n      if (value === true && !handler.isActive) {\n        handler.start();\n      } else if (value === false && handler.isActive) {\n        handler.stop();\n      }\n    });\n  }\n\n  /**\n   * Get whether the document manager has been disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Dispose of the resources held by the document manager.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n\n    // Clear any listeners for our signals.\n    Signal.clearData(this);\n\n    // Close all the widgets for our contexts and dispose the widget manager.\n    this._contexts.forEach(context => {\n      this._widgetManager.closeWidgets(context);\n    });\n    this._widgetManager.dispose();\n\n    // Clear the context list.\n    this._contexts.length = 0;\n  }\n\n  /**\n   * Clone a widget.\n   *\n   * @param widget - The source widget.\n   *\n   * @returns A new widget or `undefined`.\n   *\n   * #### Notes\n   *  Uses the same widget factory and context as the source, or returns\n   *  `undefined` if the source widget is not managed by this manager.\n   */\n  cloneWidget(widget: Widget): IDocumentWidget | undefined {\n    return this._widgetManager.cloneWidget(widget);\n  }\n\n  /**\n   * Close all of the open documents.\n   *\n   * @returns A promise resolving when the widgets are closed.\n   */\n  closeAll(): Promise<void> {\n    return Promise.all(\n      this._contexts.map(context => this._widgetManager.closeWidgets(context))\n    ).then(() => undefined);\n  }\n\n  /**\n   * Close the widgets associated with a given path.\n   *\n   * @param path - The target path.\n   *\n   * @returns A promise resolving when the widgets are closed.\n   */\n  closeFile(path: string): Promise<void> {\n    const close = this._contextsForPath(path).map(c =>\n      this._widgetManager.closeWidgets(c)\n    );\n    return Promise.all(close).then(x => undefined);\n  }\n\n  /**\n   * Get the document context for a widget.\n   *\n   * @param widget - The widget of interest.\n   *\n   * @returns The context associated with the widget, or `undefined` if no such\n   * context exists.\n   */\n  contextForWidget(widget: Widget): DocumentRegistry.Context | undefined {\n    return this._widgetManager.contextForWidget(widget);\n  }\n\n  /**\n   * Copy a file.\n   *\n   * @param fromFile - The full path of the original file.\n   *\n   * @param toDir - The full path to the target directory.\n   *\n   * @returns A promise which resolves to the contents of the file.\n   */\n  copy(fromFile: string, toDir: string): Promise<Contents.IModel> {\n    return this.services.contents.copy(fromFile, toDir);\n  }\n\n  /**\n   * Create a new file and return the widget used to view it.\n   *\n   * @param path - The file path to create.\n   *\n   * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n   *\n   * @param kernel - An optional kernel name/id to override the default.\n   *\n   * @returns The created widget, or `undefined`.\n   *\n   * #### Notes\n   * This function will return `undefined` if a valid widget factory\n   * cannot be found.\n   */\n  createNew(\n    path: string,\n    widgetName = 'default',\n    kernel?: Partial<Kernel.IModel>\n  ): Widget {\n    return this._createOrOpenDocument('create', path, widgetName, kernel);\n  }\n\n  /**\n   * Delete a file.\n   *\n   * @param path - The full path to the file to be deleted.\n   *\n   * @returns A promise which resolves when the file is deleted.\n   *\n   * #### Notes\n   * If there is a running session associated with the file and no other\n   * sessions are using the kernel, the session will be shut down.\n   */\n  deleteFile(path: string): Promise<void> {\n    return this.services.sessions\n      .stopIfNeeded(path)\n      .then(() => {\n        return this.services.contents.delete(path);\n      })\n      .then(() => {\n        this._contextsForPath(path).forEach(context =>\n          this._widgetManager.deleteWidgets(context)\n        );\n        return Promise.resolve(void 0);\n      });\n  }\n\n  /**\n   * See if a widget already exists for the given path and widget name.\n   *\n   * @param path - The file path to use.\n   *\n   * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n   *\n   * @returns The found widget, or `undefined`.\n   *\n   * #### Notes\n   * This can be used to find an existing widget instead of opening\n   * a new widget.\n   */\n  findWidget(\n    path: string,\n    widgetName = 'default'\n  ): IDocumentWidget | undefined {\n    let newPath = PathExt.normalize(path);\n    if (widgetName === 'default') {\n      let factory = this.registry.defaultWidgetFactory(newPath);\n      if (!factory) {\n        return undefined;\n      }\n      widgetName = factory.name;\n    }\n\n    for (let context of this._contextsForPath(newPath)) {\n      let widget = this._widgetManager.findWidget(context, widgetName);\n      if (widget) {\n        return widget;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Create a new untitled file.\n   *\n   * @param options - The file content creation options.\n   */\n  newUntitled(options: Contents.ICreateOptions): Promise<Contents.IModel> {\n    if (options.type === 'file') {\n      options.ext = options.ext || '.txt';\n    }\n    return this.services.contents.newUntitled(options);\n  }\n\n  /**\n   * Open a file and return the widget used to view it.\n   *\n   * @param path - The file path to open.\n   *\n   * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n   *\n   * @param kernel - An optional kernel name/id to override the default.\n   *\n   * @returns The created widget, or `undefined`.\n   *\n   * #### Notes\n   * This function will return `undefined` if a valid widget factory\n   * cannot be found.\n   */\n  open(\n    path: string,\n    widgetName = 'default',\n    kernel?: Partial<Kernel.IModel>,\n    options?: DocumentRegistry.IOpenOptions\n  ): IDocumentWidget | undefined {\n    return this._createOrOpenDocument(\n      'open',\n      path,\n      widgetName,\n      kernel,\n      options\n    );\n  }\n\n  /**\n   * Open a file and return the widget used to view it.\n   * Reveals an already existing editor.\n   *\n   * @param path - The file path to open.\n   *\n   * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n   *\n   * @param kernel - An optional kernel name/id to override the default.\n   *\n   * @returns The created widget, or `undefined`.\n   *\n   * #### Notes\n   * This function will return `undefined` if a valid widget factory\n   * cannot be found.\n   */\n  openOrReveal(\n    path: string,\n    widgetName = 'default',\n    kernel?: Partial<Kernel.IModel>,\n    options?: DocumentRegistry.IOpenOptions\n  ): IDocumentWidget | undefined {\n    let widget = this.findWidget(path, widgetName);\n    if (widget) {\n      this._opener.open(widget, options || {});\n      return widget;\n    }\n    return this.open(path, widgetName, kernel, options || {});\n  }\n\n  /**\n   * Overwrite a file.\n   *\n   * @param oldPath - The full path to the original file.\n   *\n   * @param newPath - The full path to the new file.\n   *\n   * @returns A promise containing the new file contents model.\n   */\n  overwrite(oldPath: string, newPath: string): Promise<Contents.IModel> {\n    // Cleanly overwrite the file by moving it, making sure the original does\n    // not exist, and then renaming to the new path.\n    const tempPath = `${newPath}.${UUID.uuid4()}`;\n    const cb = () => this.rename(tempPath, newPath);\n    return this.rename(oldPath, tempPath)\n      .then(() => {\n        return this.deleteFile(newPath);\n      })\n      .then(cb, cb);\n  }\n\n  /**\n   * Rename a file or directory.\n   *\n   * @param oldPath - The full path to the original file.\n   *\n   * @param newPath - The full path to the new file.\n   *\n   * @returns A promise containing the new file contents model.  The promise\n   * will reject if the newPath already exists.  Use [[overwrite]] to overwrite\n   * a file.\n   */\n  rename(oldPath: string, newPath: string): Promise<Contents.IModel> {\n    return this.services.contents.rename(oldPath, newPath);\n  }\n\n  /**\n   * Find a context for a given path and factory name.\n   */\n  private _findContext(\n    path: string,\n    factoryName: string\n  ): Private.IContext | undefined {\n    return find(this._contexts, context => {\n      return context.path === path && context.factoryName === factoryName;\n    });\n  }\n\n  /**\n   * Get the contexts for a given path.\n   *\n   * #### Notes\n   * There may be more than one context for a given path if the path is open\n   * with multiple model factories (for example, a notebook can be open with a\n   * notebook model factory and a text model factory).\n   */\n  private _contextsForPath(path: string): Private.IContext[] {\n    return this._contexts.filter(context => context.path === path);\n  }\n\n  /**\n   * Create a context from a path and a model factory.\n   */\n  private _createContext(\n    path: string,\n    factory: DocumentRegistry.ModelFactory,\n    kernelPreference: IClientSession.IKernelPreference\n  ): Private.IContext {\n    // TODO: Make it impossible to open two different contexts for the same\n    // path. Or at least prompt the closing of all widgets associated with the\n    // old context before opening the new context. This will make things much\n    // more consistent for the users, at the cost of some confusion about what\n    // models are and why sometimes they cannot open the same file in different\n    // widgets that have different models.\n\n    // Allow options to be passed when adding a sibling.\n    let adopter = (\n      widget: IDocumentWidget,\n      options?: DocumentRegistry.IOpenOptions\n    ) => {\n      this._widgetManager.adoptWidget(context, widget);\n      this._opener.open(widget, options);\n    };\n    let modelDBFactory =\n      this.services.contents.getModelDBFactory(path) || undefined;\n    let context = new Context({\n      opener: adopter,\n      manager: this.services,\n      factory,\n      path,\n      kernelPreference,\n      modelDBFactory,\n      setBusy: this._setBusy\n    });\n    let handler = new SaveHandler({ context });\n    Private.saveHandlerProperty.set(context, handler);\n    context.ready.then(() => {\n      if (this.autosave) {\n        handler.start();\n      }\n    });\n    context.disposed.connect(this._onContextDisposed, this);\n    this._contexts.push(context);\n    return context;\n  }\n\n  /**\n   * Handle a context disposal.\n   */\n  private _onContextDisposed(context: Private.IContext): void {\n    ArrayExt.removeFirstOf(this._contexts, context);\n  }\n\n  /**\n   * Get the widget factory for a given widget name.\n   */\n  private _widgetFactoryFor(\n    path: string,\n    widgetName: string\n  ): DocumentRegistry.WidgetFactory | undefined {\n    let { registry } = this;\n    if (widgetName === 'default') {\n      let factory = registry.defaultWidgetFactory(path);\n      if (!factory) {\n        return undefined;\n      }\n      widgetName = factory.name;\n    }\n    return registry.getWidgetFactory(widgetName);\n  }\n\n  /**\n   * Creates a new document, or loads one from disk, depending on the `which` argument.\n   * If `which==='create'`, then it creates a new document. If `which==='open'`,\n   * then it loads the document from disk.\n   *\n   * The two cases differ in how the document context is handled, but the creation\n   * of the widget and launching of the kernel are identical.\n   */\n  private _createOrOpenDocument(\n    which: 'open' | 'create',\n    path: string,\n    widgetName = 'default',\n    kernel?: Partial<Kernel.IModel>,\n    options?: DocumentRegistry.IOpenOptions\n  ): IDocumentWidget | undefined {\n    let widgetFactory = this._widgetFactoryFor(path, widgetName);\n    if (!widgetFactory) {\n      return undefined;\n    }\n    let modelName = widgetFactory.modelName || 'text';\n    let factory = this.registry.getModelFactory(modelName);\n    if (!factory) {\n      return undefined;\n    }\n\n    // Handle the kernel pereference.\n    let preference = this.registry.getKernelPreference(\n      path,\n      widgetFactory.name,\n      kernel\n    );\n\n    let context: Private.IContext | null = null;\n    let ready: Promise<void> = Promise.resolve(undefined);\n\n    // Handle the load-from-disk case\n    if (which === 'open') {\n      // Use an existing context if available.\n      context = this._findContext(path, factory.name) || null;\n      if (!context) {\n        context = this._createContext(path, factory, preference);\n        // Populate the model, either from disk or a\n        // model backend.\n        ready = this._when.then(() => context.initialize(false));\n      }\n    } else if (which === 'create') {\n      context = this._createContext(path, factory, preference);\n      // Immediately save the contents to disk.\n      ready = this._when.then(() => context.initialize(true));\n    }\n\n    let widget = this._widgetManager.createWidget(widgetFactory, context!);\n    this._opener.open(widget, options || {});\n\n    // If the initial opening of the context fails, dispose of the widget.\n    ready.catch(err => {\n      widget.close();\n    });\n\n    return widget;\n  }\n\n  /**\n   * Handle an activateRequested signal from the widget manager.\n   */\n  private _onActivateRequested(\n    sender: DocumentWidgetManager,\n    args: string\n  ): void {\n    this._activateRequested.emit(args);\n  }\n\n  private _activateRequested = new Signal<this, string>(this);\n  private _contexts: Private.IContext[] = [];\n  private _opener: DocumentManager.IWidgetOpener;\n  private _widgetManager: DocumentWidgetManager;\n  private _isDisposed = false;\n  private _autosave = true;\n  private _when: Promise<void>;\n  private _setBusy: () => IDisposable;\n}\n\n/**\n * A namespace for document manager statics.\n */\nexport namespace DocumentManager {\n  /**\n   * The options used to initialize a document manager.\n   */\n  export interface IOptions {\n    /**\n     * A document registry instance.\n     */\n    registry: DocumentRegistry;\n\n    /**\n     * A service manager instance.\n     */\n    manager: ServiceManager.IManager;\n\n    /**\n     * A widget opener for sibling widgets.\n     */\n    opener: IWidgetOpener;\n\n    /**\n     * A promise for when to start using the manager.\n     */\n    when?: Promise<void>;\n\n    /**\n     * A function called when a kernel is busy.\n     */\n    setBusy?: () => IDisposable;\n  }\n\n  /**\n   * An interface for a widget opener.\n   */\n  export interface IWidgetOpener {\n    /**\n     * Open the given widget.\n     */\n    open(\n      widget: IDocumentWidget,\n      options?: DocumentRegistry.IOpenOptions\n    ): void;\n  }\n}\n\n/**\n * A namespace for private data.\n */\nnamespace Private {\n  /**\n   * An attached property for a context save handler.\n   */\n  export const saveHandlerProperty = new AttachedProperty<\n    DocumentRegistry.Context,\n    SaveHandler | undefined\n  >({\n    name: 'saveHandler',\n    create: () => undefined\n  });\n\n  /**\n   * A type alias for a standard context.\n   *\n   * #### Notes\n   * We define this as an interface of a specific implementation so that we can\n   * use the implementation-specific functions.\n   */\n  export interface IContext extends Context<DocumentRegistry.IModel> {\n    /* no op */\n  }\n}\n"]}