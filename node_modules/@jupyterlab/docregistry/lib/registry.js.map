{"version":3,"file":"registry.js","sourceRoot":"","sources":["../../../../docregistry/src/registry.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { Contents, Kernel } from '@jupyterlab/services';\n\nimport {\n  ArrayExt,\n  ArrayIterator,\n  IIterator,\n  each,\n  empty,\n  find,\n  map\n} from '@phosphor/algorithm';\n\nimport { JSONValue } from '@phosphor/coreutils';\n\nimport { IDisposable, DisposableDelegate } from '@phosphor/disposable';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { DockLayout, Widget } from '@phosphor/widgets';\n\nimport { IClientSession, Toolbar } from '@jupyterlab/apputils';\n\nimport { CodeEditor } from '@jupyterlab/codeeditor';\n\nimport {\n  IChangedArgs as IChangedArgsGeneric,\n  PathExt\n} from '@jupyterlab/coreutils';\n\nimport { IModelDB } from '@jupyterlab/observables';\n\nimport { IRenderMime } from '@jupyterlab/rendermime-interfaces';\n\nimport { TextModelFactory } from './default';\n\n/**\n * The document registry.\n */\nexport class DocumentRegistry implements IDisposable {\n  /**\n   * Construct a new document registry.\n   */\n  constructor(options: DocumentRegistry.IOptions = {}) {\n    let factory = options.textModelFactory;\n    if (factory && factory.name !== 'text') {\n      throw new Error('Text model factory must have the name `text`');\n    }\n    this._modelFactories['text'] = factory || new TextModelFactory();\n\n    let fts = options.initialFileTypes || DocumentRegistry.defaultFileTypes;\n    fts.forEach(ft => {\n      let value: DocumentRegistry.IFileType = {\n        ...DocumentRegistry.fileTypeDefaults,\n        ...ft\n      };\n      this._fileTypes.push(value);\n    });\n  }\n\n  /**\n   * A signal emitted when the registry has changed.\n   */\n  get changed(): ISignal<this, DocumentRegistry.IChangedArgs> {\n    return this._changed;\n  }\n\n  /**\n   * Get whether the document registry has been disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Dispose of the resources held by the document registery.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    for (let modelName in this._modelFactories) {\n      this._modelFactories[modelName].dispose();\n    }\n    for (let widgetName in this._widgetFactories) {\n      this._widgetFactories[widgetName].dispose();\n    }\n    for (let widgetName in this._extenders) {\n      this._extenders[widgetName].length = 0;\n    }\n\n    this._fileTypes.length = 0;\n    Signal.clearData(this);\n  }\n\n  /**\n   * Add a widget factory to the registry.\n   *\n   * @param factory - The factory instance to register.\n   *\n   * @returns A disposable which will unregister the factory.\n   *\n   * #### Notes\n   * If a factory with the given `'displayName'` is already registered,\n   * a warning will be logged, and this will be a no-op.\n   * If `'*'` is given as a default extension, the factory will be registered\n   * as the global default.\n   * If an extension or global default is already registered, this factory\n   * will override the existing default.\n   */\n  addWidgetFactory(factory: DocumentRegistry.WidgetFactory): IDisposable {\n    let name = factory.name.toLowerCase();\n    if (this._widgetFactories[name]) {\n      console.warn(`Duplicate registered factory ${name}`);\n      return new DisposableDelegate(Private.noOp);\n    }\n    this._widgetFactories[name] = factory;\n    for (let ft of factory.defaultFor || []) {\n      if (factory.fileTypes.indexOf(ft) === -1) {\n        continue;\n      }\n      if (ft === '*') {\n        this._defaultWidgetFactory = name;\n      } else {\n        this._defaultWidgetFactories[ft] = name;\n      }\n    }\n    for (let ft of factory.defaultRendered || []) {\n      if (factory.fileTypes.indexOf(ft) === -1) {\n        continue;\n      }\n      this._defaultRenderedWidgetFactories[ft] = name;\n    }\n    // For convenience, store a mapping of file type name -> name\n    for (let ft of factory.fileTypes) {\n      if (!this._widgetFactoryExtensions[ft]) {\n        this._widgetFactoryExtensions[ft] = [];\n      }\n      this._widgetFactoryExtensions[ft].push(name);\n    }\n    this._changed.emit({\n      type: 'widgetFactory',\n      name,\n      change: 'added'\n    });\n    return new DisposableDelegate(() => {\n      delete this._widgetFactories[name];\n      if (this._defaultWidgetFactory === name) {\n        this._defaultWidgetFactory = '';\n      }\n      for (let ext of Object.keys(this._defaultWidgetFactories)) {\n        if (this._defaultWidgetFactories[ext] === name) {\n          delete this._defaultWidgetFactories[ext];\n        }\n      }\n      for (let ext of Object.keys(this._defaultRenderedWidgetFactories)) {\n        if (this._defaultRenderedWidgetFactories[ext] === name) {\n          delete this._defaultRenderedWidgetFactories[ext];\n        }\n      }\n      for (let ext of Object.keys(this._widgetFactoryExtensions)) {\n        ArrayExt.removeFirstOf(this._widgetFactoryExtensions[ext], name);\n        if (this._widgetFactoryExtensions[ext].length === 0) {\n          delete this._widgetFactoryExtensions[ext];\n        }\n      }\n      this._changed.emit({\n        type: 'widgetFactory',\n        name,\n        change: 'removed'\n      });\n    });\n  }\n\n  /**\n   * Add a model factory to the registry.\n   *\n   * @param factory - The factory instance.\n   *\n   * @returns A disposable which will unregister the factory.\n   *\n   * #### Notes\n   * If a factory with the given `name` is already registered, or\n   * the given factory is already registered, a warning will be logged\n   * and this will be a no-op.\n   */\n  addModelFactory(factory: DocumentRegistry.ModelFactory): IDisposable {\n    let name = factory.name.toLowerCase();\n    if (this._modelFactories[name]) {\n      console.warn(`Duplicate registered factory ${name}`);\n      return new DisposableDelegate(Private.noOp);\n    }\n    this._modelFactories[name] = factory;\n    this._changed.emit({\n      type: 'modelFactory',\n      name,\n      change: 'added'\n    });\n    return new DisposableDelegate(() => {\n      delete this._modelFactories[name];\n      this._changed.emit({\n        type: 'modelFactory',\n        name,\n        change: 'removed'\n      });\n    });\n  }\n\n  /**\n   * Add a widget extension to the registry.\n   *\n   * @param widgetName - The name of the widget factory.\n   *\n   * @param extension - A widget extension.\n   *\n   * @returns A disposable which will unregister the extension.\n   *\n   * #### Notes\n   * If the extension is already registered for the given\n   * widget name, a warning will be logged and this will be a no-op.\n   */\n  addWidgetExtension(\n    widgetName: string,\n    extension: DocumentRegistry.WidgetExtension\n  ): IDisposable {\n    widgetName = widgetName.toLowerCase();\n    if (!(widgetName in this._extenders)) {\n      this._extenders[widgetName] = [];\n    }\n    let extenders = this._extenders[widgetName];\n    let index = ArrayExt.firstIndexOf(extenders, extension);\n    if (index !== -1) {\n      console.warn(`Duplicate registered extension for ${widgetName}`);\n      return new DisposableDelegate(Private.noOp);\n    }\n    this._extenders[widgetName].push(extension);\n    this._changed.emit({\n      type: 'widgetExtension',\n      name: widgetName,\n      change: 'added'\n    });\n    return new DisposableDelegate(() => {\n      ArrayExt.removeFirstOf(this._extenders[widgetName], extension);\n      this._changed.emit({\n        type: 'widgetExtension',\n        name: widgetName,\n        change: 'removed'\n      });\n    });\n  }\n\n  /**\n   * Add a file type to the document registry.\n   *\n   * @params fileType - The file type object to register.\n   *\n   * @returns A disposable which will unregister the command.\n   *\n   * #### Notes\n   * These are used to populate the \"Create New\" dialog.\n   */\n  addFileType(fileType: Partial<DocumentRegistry.IFileType>): IDisposable {\n    let value: DocumentRegistry.IFileType = {\n      ...DocumentRegistry.fileTypeDefaults,\n      ...fileType\n    };\n    this._fileTypes.push(value);\n\n    this._changed.emit({\n      type: 'fileType',\n      name: value.name,\n      change: 'added'\n    });\n    return new DisposableDelegate(() => {\n      ArrayExt.removeFirstOf(this._fileTypes, value);\n      this._changed.emit({\n        type: 'fileType',\n        name: fileType.name,\n        change: 'removed'\n      });\n    });\n  }\n\n  /**\n   * Get a list of the preferred widget factories.\n   *\n   * @param path - The file path to filter the results.\n   *\n   * @returns A new array of widget factories.\n   *\n   * #### Notes\n   * Only the widget factories whose associated model factory have\n   * been registered will be returned.\n   * The first item is considered the default. The returned array\n   * has widget factories in the following order:\n   * - path-specific default factory\n   * - path-specific default rendered factory\n   * - global default factory\n   * - all other path-specific factories\n   * - all other global factories\n   */\n  preferredWidgetFactories(path: string): DocumentRegistry.WidgetFactory[] {\n    let factories = new Set<string>();\n\n    // Get the ordered matching file types.\n    let fts = this.getFileTypesForPath(PathExt.basename(path));\n\n    // Start with the file type default factories.\n    fts.forEach(ft => {\n      if (ft.name in this._defaultWidgetFactories) {\n        factories.add(this._defaultWidgetFactories[ft.name]);\n      }\n    });\n\n    // Add the file type default rendered factories.\n    fts.forEach(ft => {\n      if (ft.name in this._defaultRenderedWidgetFactories) {\n        factories.add(this._defaultRenderedWidgetFactories[ft.name]);\n      }\n    });\n\n    // Add the global default factory.\n    if (this._defaultWidgetFactory) {\n      factories.add(this._defaultWidgetFactory);\n    }\n\n    // Add the file type factories in registration order.\n    fts.forEach(ft => {\n      if (ft.name in this._widgetFactoryExtensions) {\n        each(this._widgetFactoryExtensions[ft.name], n => {\n          factories.add(n);\n        });\n      }\n    });\n\n    // Add the rest of the global factories, in registration order.\n    if ('*' in this._widgetFactoryExtensions) {\n      each(this._widgetFactoryExtensions['*'], n => {\n        factories.add(n);\n      });\n    }\n\n    // Construct the return list, checking to make sure the corresponding\n    // model factories are registered.\n    let factoryList: DocumentRegistry.WidgetFactory[] = [];\n    factories.forEach(name => {\n      let factory = this._widgetFactories[name];\n      if (!factory) {\n        return;\n      }\n      let modelName = factory.modelName || 'text';\n      if (modelName in this._modelFactories) {\n        factoryList.push(factory);\n      }\n    });\n\n    return factoryList;\n  }\n\n  /**\n   * Get the default rendered widget factory for a path.\n   *\n   * @param path - The path to for which to find a widget factory.\n   *\n   * @returns The default rendered widget factory for the path.\n   *\n   * ### Notes\n   * If the widget factory has registered a separate set of `defaultRendered`\n   * file types and there is a match in that set, this returns that.\n   * Otherwise, this returns the same widget factory as\n   * [[defaultWidgetFactory]].\n   */\n  defaultRenderedWidgetFactory(path: string): DocumentRegistry.WidgetFactory {\n    // Get the matching file types.\n    let fts = this.getFileTypesForPath(PathExt.basename(path));\n\n    let factory: DocumentRegistry.WidgetFactory = undefined;\n    // Find if a there is a default rendered factory for this type.\n    for (let ft of fts) {\n      if (ft.name in this._defaultRenderedWidgetFactories) {\n        factory = this._widgetFactories[\n          this._defaultRenderedWidgetFactories[ft.name]\n        ];\n        break;\n      }\n    }\n    return factory || this.defaultWidgetFactory(path);\n  }\n\n  /**\n   * Get the default widget factory for a path.\n   *\n   * @param path - An optional file path to filter the results.\n   *\n   * @returns The default widget factory for an path.\n   *\n   * #### Notes\n   * This is equivalent to the first value in [[preferredWidgetFactories]].\n   */\n  defaultWidgetFactory(path?: string): DocumentRegistry.WidgetFactory {\n    if (!path) {\n      return this._widgetFactories[this._defaultWidgetFactory];\n    }\n    return this.preferredWidgetFactories(path)[0];\n  }\n\n  /**\n   * Create an iterator over the widget factories that have been registered.\n   *\n   * @returns A new iterator of widget factories.\n   */\n  widgetFactories(): IIterator<DocumentRegistry.WidgetFactory> {\n    return map(Object.keys(this._widgetFactories), name => {\n      return this._widgetFactories[name];\n    });\n  }\n\n  /**\n   * Create an iterator over the model factories that have been registered.\n   *\n   * @returns A new iterator of model factories.\n   */\n  modelFactories(): IIterator<DocumentRegistry.ModelFactory> {\n    return map(Object.keys(this._modelFactories), name => {\n      return this._modelFactories[name];\n    });\n  }\n\n  /**\n   * Create an iterator over the registered extensions for a given widget.\n   *\n   * @param widgetName - The name of the widget factory.\n   *\n   * @returns A new iterator over the widget extensions.\n   */\n  widgetExtensions(\n    widgetName: string\n  ): IIterator<DocumentRegistry.WidgetExtension> {\n    widgetName = widgetName.toLowerCase();\n    if (!(widgetName in this._extenders)) {\n      return empty<DocumentRegistry.WidgetExtension>();\n    }\n    return new ArrayIterator(this._extenders[widgetName]);\n  }\n\n  /**\n   * Create an iterator over the file types that have been registered.\n   *\n   * @returns A new iterator of file types.\n   */\n  fileTypes(): IIterator<DocumentRegistry.IFileType> {\n    return new ArrayIterator(this._fileTypes);\n  }\n\n  /**\n   * Get a widget factory by name.\n   *\n   * @param widgetName - The name of the widget factory.\n   *\n   * @returns A widget factory instance.\n   */\n  getWidgetFactory(\n    widgetName: string\n  ): DocumentRegistry.WidgetFactory | undefined {\n    return this._widgetFactories[widgetName.toLowerCase()];\n  }\n\n  /**\n   * Get a model factory by name.\n   *\n   * @param name - The name of the model factory.\n   *\n   * @returns A model factory instance.\n   */\n  getModelFactory(name: string): DocumentRegistry.ModelFactory | undefined {\n    return this._modelFactories[name.toLowerCase()];\n  }\n\n  /**\n   * Get a file type by name.\n   */\n  getFileType(name: string): DocumentRegistry.IFileType | undefined {\n    name = name.toLowerCase();\n    return find(this._fileTypes, fileType => {\n      return fileType.name.toLowerCase() === name;\n    });\n  }\n\n  /**\n   * Get a kernel preference.\n   *\n   * @param path - The file path.\n   *\n   * @param widgetName - The name of the widget factory.\n   *\n   * @param kernel - An optional existing kernel model.\n   *\n   * @returns A kernel preference.\n   */\n  getKernelPreference(\n    path: string,\n    widgetName: string,\n    kernel?: Partial<Kernel.IModel>\n  ): IClientSession.IKernelPreference | undefined {\n    widgetName = widgetName.toLowerCase();\n    let widgetFactory = this._widgetFactories[widgetName];\n    if (!widgetFactory) {\n      return void 0;\n    }\n    let modelFactory = this.getModelFactory(widgetFactory.modelName || 'text');\n    if (!modelFactory) {\n      return void 0;\n    }\n    let language = modelFactory.preferredLanguage(PathExt.basename(path));\n    let name = kernel && kernel.name;\n    let id = kernel && kernel.id;\n    return {\n      id,\n      name,\n      language,\n      shouldStart: widgetFactory.preferKernel,\n      canStart: widgetFactory.canStartKernel\n    };\n  }\n\n  /**\n   * Get the best file type given a contents model.\n   *\n   * @param model - The contents model of interest.\n   *\n   * @returns The best matching file type.\n   */\n  getFileTypeForModel(\n    model: Partial<Contents.IModel>\n  ): DocumentRegistry.IFileType {\n    switch (model.type) {\n      case 'directory':\n        return (\n          find(this._fileTypes, ft => ft.contentType === 'directory') ||\n          DocumentRegistry.defaultDirectoryFileType\n        );\n      case 'notebook':\n        return (\n          find(this._fileTypes, ft => ft.contentType === 'notebook') ||\n          DocumentRegistry.defaultNotebookFileType\n        );\n      default:\n        // Find the best matching extension.\n        if (model.name || model.path) {\n          let name = model.name || PathExt.basename(model.path);\n          let fts = this.getFileTypesForPath(name);\n          if (fts.length > 0) {\n            return fts[0];\n          }\n        }\n        return this.getFileType('text') || DocumentRegistry.defaultTextFileType;\n    }\n  }\n\n  /**\n   * Get the file types that match a file name.\n   *\n   * @param path - The path of the file.\n   *\n   * @returns An ordered list of matching file types.\n   */\n  getFileTypesForPath(path: string): DocumentRegistry.IFileType[] {\n    let fts: DocumentRegistry.IFileType[] = [];\n    let name = PathExt.basename(path);\n\n    // Look for a pattern match first.\n    let ft = find(this._fileTypes, ft => {\n      return ft.pattern && ft.pattern.match(name) !== null;\n    });\n    if (ft) {\n      fts.push(ft);\n    }\n\n    // Then look by extension name, starting with the longest\n    let ext = Private.extname(name);\n    while (ext.length > 1) {\n      ft = find(this._fileTypes, ft => ft.extensions.indexOf(ext) !== -1);\n      if (ft) {\n        fts.push(ft);\n      }\n      ext =\n        '.' +\n        ext\n          .split('.')\n          .slice(2)\n          .join('.');\n    }\n    return fts;\n  }\n\n  private _modelFactories: {\n    [key: string]: DocumentRegistry.ModelFactory;\n  } = Object.create(null);\n  private _widgetFactories: {\n    [key: string]: DocumentRegistry.WidgetFactory;\n  } = Object.create(null);\n  private _defaultWidgetFactory = '';\n  private _defaultWidgetFactories: { [key: string]: string } = Object.create(\n    null\n  );\n  private _defaultRenderedWidgetFactories: {\n    [key: string]: string;\n  } = Object.create(null);\n  private _widgetFactoryExtensions: { [key: string]: string[] } = Object.create(\n    null\n  );\n  private _fileTypes: DocumentRegistry.IFileType[] = [];\n  private _extenders: {\n    [key: string]: DocumentRegistry.WidgetExtension[];\n  } = Object.create(null);\n  private _changed = new Signal<this, DocumentRegistry.IChangedArgs>(this);\n  private _isDisposed = false;\n}\n\n/**\n * The namespace for the `DocumentRegistry` class statics.\n */\nexport namespace DocumentRegistry {\n  /**\n   * The options used to create a document registry.\n   */\n  export interface IOptions {\n    /**\n     * The text model factory for the registry.  A default instance will\n     * be used if not given.\n     */\n    textModelFactory?: ModelFactory;\n\n    /**\n     * The initial file types for the registry.\n     * The [[DocumentRegistry.defaultFileTypes]] will be used if not given.\n     */\n    initialFileTypes?: DocumentRegistry.IFileType[];\n  }\n\n  /**\n   * The interface for a document model.\n   */\n  export interface IModel extends IDisposable {\n    /**\n     * A signal emitted when the document content changes.\n     */\n    contentChanged: ISignal<this, void>;\n\n    /**\n     * A signal emitted when the model state changes.\n     */\n    stateChanged: ISignal<this, IChangedArgsGeneric<any>>;\n\n    /**\n     * The dirty state of the model.\n     *\n     * #### Notes\n     * This should be cleared when the document is loaded from\n     * or saved to disk.\n     */\n    dirty: boolean;\n\n    /**\n     * The read-only state of the model.\n     */\n    readOnly: boolean;\n\n    /**\n     * The default kernel name of the document.\n     */\n    readonly defaultKernelName: string;\n\n    /**\n     * The default kernel language of the document.\n     */\n    readonly defaultKernelLanguage: string;\n\n    /**\n     * The underlying `IModelDB` instance in which model\n     * data is stored.\n     *\n     * ### Notes\n     * Making direct edits to the values stored in the`IModelDB`\n     * is not recommended, and may produce unpredictable results.\n     */\n    readonly modelDB: IModelDB;\n\n    /**\n     * Serialize the model to a string.\n     */\n    toString(): string;\n\n    /**\n     * Deserialize the model from a string.\n     *\n     * #### Notes\n     * Should emit a [contentChanged] signal.\n     */\n    fromString(value: string): void;\n\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON(): JSONValue;\n\n    /**\n     * Deserialize the model from JSON.\n     *\n     * #### Notes\n     * Should emit a [contentChanged] signal.\n     */\n    fromJSON(value: any): void;\n\n    /**\n     * Initialize model state after initial data load.\n     *\n     * #### Notes\n     * This function must be called after the initial data is loaded to set up\n     * initial model state, such as an initial undo stack, etc.\n     */\n    initialize(): void;\n  }\n\n  /**\n   * The interface for a document model that represents code.\n   */\n  export interface ICodeModel extends IModel, CodeEditor.IModel {}\n\n  /**\n   * The document context object.\n   */\n  export interface IContext<T extends IModel> extends IDisposable {\n    /**\n     * A signal emitted when the path changes.\n     */\n    pathChanged: ISignal<this, string>;\n\n    /**\n     * A signal emitted when the contentsModel changes.\n     */\n    fileChanged: ISignal<this, Contents.IModel>;\n\n    /**\n     * A signal emitted on the start and end of a saving operation.\n     */\n    saveState: ISignal<this, SaveState>;\n\n    /**\n     * A signal emitted when the context is disposed.\n     */\n    disposed: ISignal<this, void>;\n\n    /**\n     * The data model for the document.\n     */\n    readonly model: T;\n\n    /**\n     * The client session object associated with the context.\n     */\n    readonly session: IClientSession;\n\n    /**\n     * The current path associated with the document.\n     */\n    readonly path: string;\n\n    /**\n     * The current local path associated with the document.\n     * If the document is in the default notebook file browser,\n     * this is the same as the path.\n     */\n    readonly localPath: string;\n\n    /**\n     * The document metadata, stored as a services contents model.\n     *\n     * #### Notes\n     * This will be null until the context is 'ready'. Since we only store\n     * metadata here, the `.contents` attribute will always be empty.\n     */\n    readonly contentsModel: Contents.IModel | null;\n\n    /**\n     * The url resolver for the context.\n     */\n    readonly urlResolver: IRenderMime.IResolver;\n\n    /**\n     * Whether the context is ready.\n     */\n    readonly isReady: boolean;\n\n    /**\n     * A promise that is fulfilled when the context is ready.\n     */\n    readonly ready: Promise<void>;\n\n    /**\n     * Save the document contents to disk.\n     */\n    save(): Promise<void>;\n\n    /**\n     * Save the document to a different path chosen by the user.\n     */\n    saveAs(): Promise<void>;\n\n    /**\n     * Revert the document contents to disk contents.\n     */\n    revert(): Promise<void>;\n\n    /**\n     * Create a checkpoint for the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    createCheckpoint(): Promise<Contents.ICheckpointModel>;\n\n    /**\n     * Delete a checkpoint for the file.\n     *\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    deleteCheckpoint(checkpointID: string): Promise<void>;\n\n    /**\n     * Restore the file to a known checkpoint state.\n     *\n     * @param checkpointID - The optional id of the checkpoint to restore,\n     *   defaults to the most recent checkpoint.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    restoreCheckpoint(checkpointID?: string): Promise<void>;\n\n    /**\n     * List available checkpoints for the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    listCheckpoints(): Promise<Contents.ICheckpointModel[]>;\n\n    /**\n     * Add a sibling widget to the document manager.\n     *\n     * @param widget - The widget to add to the document manager.\n     *\n     * @param options - The desired options for adding the sibling.\n     *\n     * @returns A disposable used to remove the sibling if desired.\n     *\n     * #### Notes\n     * It is assumed that the widget has the same model and context\n     * as the original widget.\n     */\n    addSibling(widget: Widget, options?: IOpenOptions): IDisposable;\n  }\n\n  export type SaveState = 'started' | 'completed' | 'failed';\n\n  /**\n   * A type alias for a context.\n   */\n  export type Context = IContext<IModel>;\n\n  /**\n   * A type alias for a code context.\n   */\n  export type CodeContext = IContext<ICodeModel>;\n\n  /**\n   * The options used to initialize a widget factory.\n   */\n  export interface IWidgetFactoryOptions {\n    /**\n     * The name of the widget to display in dialogs.\n     */\n    readonly name: string;\n\n    /**\n     * The file types the widget can view.\n     */\n    readonly fileTypes: ReadonlyArray<string>;\n\n    /**\n     * The file types for which the factory should be the default.\n     */\n    readonly defaultFor?: ReadonlyArray<string>;\n\n    /**\n     * The file types for which the factory should be the default for rendering,\n     * if that is different than the default factory (which may be for editing).\n     * If undefined, then it will fall back on the default file type.\n     */\n    readonly defaultRendered?: ReadonlyArray<string>;\n\n    /**\n     * Whether the widget factory is read only.\n     */\n    readonly readOnly?: boolean;\n\n    /**\n     * The registered name of the model type used to create the widgets.\n     */\n    readonly modelName?: string;\n\n    /**\n     * Whether the widgets prefer having a kernel started.\n     */\n    readonly preferKernel?: boolean;\n\n    /**\n     * Whether the widgets can start a kernel when opened.\n     */\n    readonly canStartKernel?: boolean;\n  }\n\n  /**\n   * The options used to open a widget.\n   */\n  export interface IOpenOptions {\n    /**\n     * The reference widget id for the insert location.\n     *\n     * The default is `null`.\n     */\n    ref?: string | null;\n\n    /**\n     * The supported insertion modes.\n     *\n     * An insert mode is used to specify how a widget should be added\n     * to the main area relative to a reference widget.\n     */\n    mode?: DockLayout.InsertMode;\n\n    /**\n     * Whether to activate the widget.  Defaults to `true`.\n     */\n    activate?: boolean;\n  }\n\n  /**\n   * The interface for a widget factory.\n   */\n  export interface IWidgetFactory<T extends IDocumentWidget, U extends IModel>\n    extends IDisposable,\n      IWidgetFactoryOptions {\n    /**\n     * A signal emitted when a new widget is created.\n     */\n    widgetCreated: ISignal<IWidgetFactory<T, U>, T>;\n\n    /**\n     * Create a new widget given a context.\n     *\n     * #### Notes\n     * It should emit the [widgetCreated] signal with the new widget.\n     */\n    createNew(context: IContext<U>): T;\n  }\n\n  /**\n   * A type alias for a standard widget factory.\n   */\n  export type WidgetFactory = IWidgetFactory<IDocumentWidget, IModel>;\n\n  /**\n   * An interface for a widget extension.\n   */\n  export interface IWidgetExtension<T extends Widget, U extends IModel> {\n    /**\n     * Create a new extension for a given widget.\n     */\n    createNew(widget: T, context: IContext<U>): IDisposable;\n  }\n\n  /**\n   * A type alias for a standard widget extension.\n   */\n  export type WidgetExtension = IWidgetExtension<Widget, IModel>;\n\n  /**\n   * The interface for a model factory.\n   */\n  export interface IModelFactory<T extends IModel> extends IDisposable {\n    /**\n     * The name of the model.\n     */\n    readonly name: string;\n\n    /**\n     * The content type of the file (defaults to `\"file\"`).\n     */\n    readonly contentType: Contents.ContentType;\n\n    /**\n     * The format of the file (defaults to `\"text\"`).\n     */\n    readonly fileFormat: Contents.FileFormat;\n\n    /**\n     * Create a new model for a given path.\n     *\n     * @param languagePreference - An optional kernel language preference.\n     *\n     * @returns A new document model.\n     */\n    createNew(languagePreference?: string, modelDB?: IModelDB): T;\n\n    /**\n     * Get the preferred kernel language given a file path.\n     */\n    preferredLanguage(path: string): string;\n  }\n\n  /**\n   * A type alias for a standard model factory.\n   */\n  export type ModelFactory = IModelFactory<IModel>;\n\n  /**\n   * A type alias for a code model factory.\n   */\n  export type CodeModelFactory = IModelFactory<ICodeModel>;\n\n  /**\n   * An interface for a file type.\n   */\n  export interface IFileType {\n    /**\n     * The name of the file type.\n     */\n    readonly name: string;\n\n    /**\n     * The mime types associated the file type.\n     */\n    readonly mimeTypes: ReadonlyArray<string>;\n\n    /**\n     * The extensions of the file type (e.g. `\".txt\"`).  Can be a compound\n     * extension (e.g. `\".table.json`).\n     */\n    readonly extensions: ReadonlyArray<string>;\n\n    /**\n     * An optional display name for the file type.\n     */\n    readonly displayName?: string;\n\n    /**\n     * An optional pattern for a file name (e.g. `^Dockerfile$`).\n     */\n    readonly pattern?: string;\n\n    /**\n     * The icon class name for the file type.\n     */\n    readonly iconClass?: string;\n\n    /**\n     * The icon label for the file type.\n     */\n    readonly iconLabel?: string;\n\n    /**\n     * The content type of the new file.\n     */\n    readonly contentType: Contents.ContentType;\n\n    /**\n     * The format of the new file.\n     */\n    readonly fileFormat: Contents.FileFormat;\n  }\n\n  /**\n   * The defaults used for a file type.\n   */\n  export const fileTypeDefaults: IFileType = {\n    name: 'default',\n    extensions: [],\n    mimeTypes: [],\n    iconClass: 'jp-MaterialIcon jp-FileIcon',\n    iconLabel: '',\n    contentType: 'file',\n    fileFormat: 'text'\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   */\n  export interface IChangedArgs {\n    /**\n     * The type of the changed item.\n     */\n    readonly type:\n      | 'widgetFactory'\n      | 'modelFactory'\n      | 'widgetExtension'\n      | 'fileType';\n\n    /**\n     * The name of the item or the widget factory being extended.\n     */\n    readonly name: string;\n\n    /**\n     * Whether the item was added or removed.\n     */\n    readonly change: 'added' | 'removed';\n  }\n\n  /**\n   * The default text file type used by the document registry.\n   */\n  export const defaultTextFileType: IFileType = {\n    ...fileTypeDefaults,\n    name: 'text',\n    mimeTypes: ['text/plain'],\n    extensions: ['.txt']\n  };\n\n  /**\n   * The default notebook file type used by the document registry.\n   */\n  export const defaultNotebookFileType: IFileType = {\n    ...fileTypeDefaults,\n    name: 'notebook',\n    displayName: 'Notebook',\n    mimeTypes: ['application/x-ipynb+json'],\n    extensions: ['.ipynb'],\n    contentType: 'notebook',\n    fileFormat: 'json',\n    iconClass: 'jp-MaterialIcon jp-NotebookIcon'\n  };\n\n  /**\n   * The default directory file type used by the document registry.\n   */\n  export const defaultDirectoryFileType: IFileType = {\n    ...fileTypeDefaults,\n    name: 'directory',\n    extensions: [],\n    mimeTypes: ['text/directory'],\n    contentType: 'directory',\n    iconClass: 'jp-MaterialIcon jp-OpenFolderIcon'\n  };\n\n  /**\n   * The default file types used by the document registry.\n   */\n  export const defaultFileTypes: ReadonlyArray<Partial<IFileType>> = [\n    defaultTextFileType,\n    defaultNotebookFileType,\n    defaultDirectoryFileType,\n    {\n      name: 'markdown',\n      displayName: 'Markdown File',\n      extensions: ['.md'],\n      mimeTypes: ['text/markdown'],\n      iconClass: 'jp-MaterialIcon jp-MarkdownIcon'\n    },\n    {\n      name: 'python',\n      displayName: 'Python File',\n      extensions: ['.py'],\n      mimeTypes: ['text/x-python'],\n      iconClass: 'jp-MaterialIcon jp-PythonIcon'\n    },\n    {\n      name: 'json',\n      displayName: 'JSON File',\n      extensions: ['.json'],\n      mimeTypes: ['application/json'],\n      iconClass: 'jp-MaterialIcon jp-JSONIcon'\n    },\n    {\n      name: 'csv',\n      displayName: 'CSV File',\n      extensions: ['.csv'],\n      mimeTypes: ['text/csv'],\n      iconClass: 'jp-MaterialIcon jp-SpreadsheetIcon'\n    },\n    {\n      name: 'tsv',\n      displayName: 'TSV File',\n      extensions: ['.tsv'],\n      mimeTypes: ['text/csv'],\n      iconClass: 'jp-MaterialIcon jp-SpreadsheetIcon'\n    },\n    {\n      name: 'r',\n      displayName: 'R File',\n      mimeTypes: ['text/x-rsrc'],\n      extensions: ['.r'],\n      iconClass: 'jp-MaterialIcon jp-RKernelIcon'\n    },\n    {\n      name: 'yaml',\n      displayName: 'YAML File',\n      mimeTypes: ['text/x-yaml', 'text/yaml'],\n      extensions: ['.yaml', '.yml'],\n      iconClass: 'jp-MaterialIcon jp-YamlIcon'\n    },\n    {\n      name: 'svg',\n      displayName: 'Image',\n      mimeTypes: ['image/svg+xml'],\n      extensions: ['.svg'],\n      iconClass: 'jp-MaterialIcon jp-ImageIcon',\n      fileFormat: 'base64'\n    },\n    {\n      name: 'tiff',\n      displayName: 'Image',\n      mimeTypes: ['image/tiff'],\n      extensions: ['.tif', '.tiff'],\n      iconClass: 'jp-MaterialIcon jp-ImageIcon',\n      fileFormat: 'base64'\n    },\n    {\n      name: 'jpeg',\n      displayName: 'Image',\n      mimeTypes: ['image/jpeg'],\n      extensions: ['.jpg', '.jpeg'],\n      iconClass: 'jp-MaterialIcon jp-ImageIcon',\n      fileFormat: 'base64'\n    },\n    {\n      name: 'gif',\n      displayName: 'Image',\n      mimeTypes: ['image/gif'],\n      extensions: ['.gif'],\n      iconClass: 'jp-MaterialIcon jp-ImageIcon',\n      fileFormat: 'base64'\n    },\n    {\n      name: 'png',\n      displayName: 'Image',\n      mimeTypes: ['image/png'],\n      extensions: ['.png'],\n      iconClass: 'jp-MaterialIcon jp-ImageIcon',\n      fileFormat: 'base64'\n    },\n    {\n      name: 'bmp',\n      displayName: 'Image',\n      mimeTypes: ['image/bmp'],\n      extensions: ['.bmp'],\n      iconClass: 'jp-MaterialIcon jp-ImageIcon',\n      fileFormat: 'base64'\n    }\n  ];\n}\n\n/**\n * An interface for a document widget.\n */\nexport interface IDocumentWidget<\n  T extends Widget = Widget,\n  U extends DocumentRegistry.IModel = DocumentRegistry.IModel\n> extends Widget {\n  /**\n   * The content widget.\n   */\n  readonly content: T;\n\n  /**\n   * A promise resolving after the content widget is revealed.\n   */\n  readonly revealed: Promise<void>;\n\n  /**\n   * The context associated with the document.\n   */\n  readonly context: DocumentRegistry.IContext<U>;\n\n  /**\n   * The toolbar for the widget.\n   */\n  readonly toolbar: Toolbar<Widget>;\n}\n\n/**\n * A private namespace for DocumentRegistry data.\n */\nnamespace Private {\n  /**\n   * Get the extension name of a path.\n   *\n   * @param file - string.\n   *\n   * #### Notes\n   * Dotted filenames (e.g. `\".table.json\"` are allowed).\n   */\n  export function extname(path: string): string {\n    let parts = PathExt.basename(path).split('.');\n    parts.shift();\n    let ext = '.' + parts.join('.');\n    return ext.toLowerCase();\n  }\n  /**\n   * A no-op function.\n   */\n  export function noOp() {\n    /* no-op */\n  }\n}\n"]}