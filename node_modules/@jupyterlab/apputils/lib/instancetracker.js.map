{"version":3,"file":"instancetracker.js","sourceRoot":"","sources":["../../../../apputils/src/instancetracker.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { IStateDB } from '@jupyterlab/coreutils';\n\nimport { ArrayExt, each, find } from '@phosphor/algorithm';\n\nimport { CommandRegistry } from '@phosphor/commands';\n\nimport { ReadonlyJSONObject } from '@phosphor/coreutils';\n\nimport { IDisposable } from '@phosphor/disposable';\n\nimport { AttachedProperty } from '@phosphor/properties';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { FocusTracker, Widget } from '@phosphor/widgets';\n\n/**\n * An object that tracks widget instances.\n */\nexport interface IInstanceTracker<T extends Widget> extends IDisposable {\n  /**\n   * A signal emitted when the current widget changes.\n   *\n   * #### Notes\n   * If the last widget being tracked is disposed, `null` will be emitted.\n   */\n  readonly currentChanged: ISignal<this, T | null>;\n\n  /**\n   * A signal emitted when a widget is added.\n   *\n   * #### Notes\n   * This signal will only fire when a widget is added to the tracker. It will\n   * not fire if a widget is injected into the tracker.\n   */\n  readonly widgetAdded: ISignal<this, T>;\n\n  /**\n   * The current widget is the most recently focused or added widget.\n   *\n   * #### Notes\n   * It is the most recently focused widget, or the most recently added\n   * widget if no widget has taken focus.\n   */\n  readonly currentWidget: T | null;\n\n  /**\n   * The number of widgets held by the tracker.\n   */\n  readonly size: number;\n\n  /**\n   * Find the first widget in the tracker that satisfies a filter function.\n   *\n   * @param - fn The filter function to call on each widget.\n   *\n   * #### Notes\n   * If no widget is found, the value returned is `undefined`.\n   */\n  find(fn: (widget: T) => boolean): T | undefined;\n\n  /**\n   * Iterate through each widget in the tracker.\n   *\n   * @param fn - The function to call on each widget.\n   */\n  forEach(fn: (widget: T) => void): void;\n\n  /**\n   * Filter the widgets in the tracker based on a predicate.\n   *\n   * @param fn - The function by which to filter.\n   */\n  filter(fn: (widget: T) => boolean): T[];\n\n  /**\n   * Check if this tracker has the specified widget.\n   *\n   * @param widget - The widget whose existence is being checked.\n   */\n  has(widget: Widget): boolean;\n\n  /**\n   * Inject a foreign widget into the instance tracker.\n   *\n   * @param widget - The widget to inject into the tracker.\n   *\n   * #### Notes\n   * Any widgets injected into an instance tracker will not have their state\n   * saved by the tracker. The primary use case for widget injection is for a\n   * plugin that offers a sub-class of an extant plugin to have its instances\n   * share the same commands as the parent plugin (since most relevant commands\n   * will use the `currentWidget` of the parent plugin's instance tracker). In\n   * this situation, the sub-class plugin may well have its own instance tracker\n   * for layout and state restoration in addition to injecting its widgets into\n   * the parent plugin's instance tracker.\n   */\n  inject(widget: T): void;\n}\n\n/**\n * A class that keeps track of widget instances on an Application shell.\n *\n * #### Notes\n * The API surface area of this concrete implementation is substantially larger\n * than the instance tracker interface it implements. The interface is intended\n * for export by JupyterLab plugins that create widgets and have clients who may\n * wish to keep track of newly created widgets. This class, however, can be used\n * internally by plugins to restore state as well.\n */\nexport class InstanceTracker<T extends Widget>\n  implements IInstanceTracker<T>, IDisposable {\n  /**\n   * Create a new instance tracker.\n   *\n   * @param options - The instantiation options for an instance tracker.\n   */\n  constructor(options: InstanceTracker.IOptions) {\n    this.namespace = options.namespace;\n    this._tracker.currentChanged.connect(this._onCurrentChanged, this);\n  }\n\n  /**\n   * A signal emitted when the current widget changes.\n   */\n  get currentChanged(): ISignal<this, T | null> {\n    return this._currentChanged;\n  }\n\n  /**\n   * A signal emitted when a widget is added.\n   *\n   * #### Notes\n   * This signal will only fire when a widget is added to the tracker. It will\n   * not fire if a widget is injected into the tracker.\n   */\n  get widgetAdded(): ISignal<this, T> {\n    return this._widgetAdded;\n  }\n\n  /**\n   * A signal emitted when a widget is updated.\n   */\n  get widgetUpdated(): ISignal<this, T> {\n    return this._widgetUpdated;\n  }\n\n  /**\n   * A namespace for all tracked widgets, (e.g., `notebook`).\n   */\n  readonly namespace: string;\n\n  /**\n   * The current widget is the most recently focused or added widget.\n   *\n   * #### Notes\n   * It is the most recently focused widget, or the most recently added\n   * widget if no widget has taken focus.\n   */\n  get currentWidget(): T | null {\n    return this._currentWidget;\n  }\n\n  /**\n   * The number of widgets held by the tracker.\n   */\n  get size(): number {\n    return this._tracker.widgets.length;\n  }\n\n  /**\n   * Add a new widget to the tracker.\n   *\n   * @param widget - The widget being added.\n   */\n  add(widget: T): Promise<void> {\n    if (this._tracker.has(widget)) {\n      let warning = `${widget.id} already exists in the tracker.`;\n      console.warn(warning);\n      return Promise.reject(warning);\n    }\n    this._tracker.add(widget);\n    this._widgets.push(widget);\n\n    let injected = Private.injectedProperty.get(widget);\n    let promise: Promise<void> = Promise.resolve(void 0);\n\n    if (injected) {\n      return promise;\n    }\n\n    widget.disposed.connect(this._onWidgetDisposed, this);\n\n    // Handle widget state restoration.\n    if (this._restore) {\n      let { state } = this._restore;\n      let widgetName = this._restore.name(widget);\n\n      if (widgetName) {\n        let name = `${this.namespace}:${widgetName}`;\n        let data = this._restore.args(widget);\n\n        Private.nameProperty.set(widget, name);\n        promise = state.save(name, { data });\n      }\n    }\n\n    // If there is no focused widget, set this as the current widget.\n    if (!this._tracker.currentWidget) {\n      this._currentWidget = widget;\n      this.onCurrentChanged(widget);\n      this._currentChanged.emit(widget);\n    }\n\n    // Emit the widget added signal.\n    this._widgetAdded.emit(widget);\n\n    return promise;\n  }\n\n  /**\n   * Test whether the tracker is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Dispose of the resources held by the tracker.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    Signal.clearData(this);\n    this._tracker.dispose();\n  }\n\n  /**\n   * Find the first widget in the tracker that satisfies a filter function.\n   *\n   * @param - fn The filter function to call on each widget.\n   *\n   * #### Notes\n   * If no widget is found, the value returned is `undefined`.\n   */\n  find(fn: (widget: T) => boolean): T | undefined {\n    return find(this._tracker.widgets, fn);\n  }\n\n  /**\n   * Iterate through each widget in the tracker.\n   *\n   * @param fn - The function to call on each widget.\n   */\n  forEach(fn: (widget: T) => void): void {\n    each(this._tracker.widgets, widget => {\n      fn(widget);\n    });\n  }\n\n  /**\n   * Filter the widgets in the tracker based on a predicate.\n   *\n   * @param fn - The function by which to filter.\n   */\n  filter(fn: (widget: T) => boolean): T[] {\n    return this._tracker.widgets.filter(fn);\n  }\n\n  /**\n   * Inject a foreign widget into the instance tracker.\n   *\n   * @param widget - The widget to inject into the tracker.\n   *\n   * #### Notes\n   * Any widgets injected into an instance tracker will not have their state\n   * saved by the tracker. The primary use case for widget injection is for a\n   * plugin that offers a sub-class of an extant plugin to have its instances\n   * share the same commands as the parent plugin (since most relevant commands\n   * will use the `currentWidget` of the parent plugin's instance tracker). In\n   * this situation, the sub-class plugin may well have its own instance tracker\n   * for layout and state restoration in addition to injecting its widgets into\n   * the parent plugin's instance tracker.\n   */\n  inject(widget: T): void {\n    Private.injectedProperty.set(widget, true);\n    this.add(widget);\n  }\n\n  /**\n   * Check if this tracker has the specified widget.\n   *\n   * @param widget - The widget whose existence is being checked.\n   */\n  has(widget: Widget): boolean {\n    return this._tracker.has(widget as any);\n  }\n\n  /**\n   * Restore the widgets in this tracker's namespace.\n   *\n   * @param options - The configuration options that describe restoration.\n   *\n   * @returns A promise that resolves when restoration has completed.\n   *\n   * #### Notes\n   * This function should almost never be invoked by client code. Its primary\n   * use case is to be invoked by a layout restorer plugin that handles\n   * multiple instance trackers and, when ready, asks them each to restore their\n   * respective widgets.\n   */\n  restore(options: InstanceTracker.IRestoreOptions<T>): Promise<any> {\n    const { command, registry, state, when } = options;\n    const namespace = this.namespace;\n    const promises = when\n      ? [state.fetchNamespace(namespace)].concat(when)\n      : [state.fetchNamespace(namespace)];\n\n    this._restore = options;\n\n    return Promise.all(promises).then(([saved]) => {\n      return Promise.all(\n        saved.map(item => {\n          const { id, value } = item;\n          const args = value && (value as any).data;\n          if (args === undefined) {\n            return state.remove(item.id);\n          }\n\n          // Execute the command and if it fails, delete the state restore data.\n          return registry.execute(command, args).catch(() => state.remove(id));\n        })\n      );\n    });\n  }\n\n  /**\n   * Save the restore data for a given widget.\n   *\n   * @param widget - The widget being saved.\n   */\n  save(widget: T): void {\n    const injected = Private.injectedProperty.get(widget);\n\n    if (!this._restore || !this.has(widget) || injected) {\n      return;\n    }\n\n    const { state } = this._restore;\n    const widgetName = this._restore.name(widget);\n    const oldName = Private.nameProperty.get(widget);\n    const newName = widgetName ? `${this.namespace}:${widgetName}` : '';\n\n    if (oldName && oldName !== newName) {\n      state.remove(oldName);\n    }\n\n    // Set the name property irrespective of whether the new name is null.\n    Private.nameProperty.set(widget, newName);\n\n    if (newName) {\n      const data = this._restore.args(widget);\n      state.save(newName, { data });\n    }\n\n    if (oldName !== newName) {\n      this._widgetUpdated.emit(widget);\n    }\n  }\n\n  /**\n   * Handle the current change event.\n   *\n   * #### Notes\n   * The default implementation is a no-op.\n   */\n  protected onCurrentChanged(value: T | null): void {\n    /* no-op */\n  }\n\n  /**\n   * Handle the current change signal from the internal focus tracker.\n   */\n  private _onCurrentChanged(\n    sender: any,\n    args: FocusTracker.IChangedArgs<T>\n  ): void {\n    // Bail if the active widget did not change.\n    if (args.newValue === this._currentWidget) {\n      return;\n    }\n\n    this._currentWidget = args.newValue;\n    this.onCurrentChanged(args.newValue);\n    this._currentChanged.emit(args.newValue);\n  }\n\n  /**\n   * Clean up after disposed widgets.\n   */\n  private _onWidgetDisposed(widget: T): void {\n    const injected = Private.injectedProperty.get(widget);\n\n    if (injected) {\n      return;\n    }\n\n    // Handle widget removal.\n    ArrayExt.removeFirstOf(this._widgets, widget);\n\n    // Handle the current widget being disposed.\n    if (widget === this._currentWidget) {\n      this._currentWidget =\n        this._tracker.currentWidget ||\n        this._widgets[this._widgets.length - 1] ||\n        null;\n      this._currentChanged.emit(this._currentWidget);\n      this.onCurrentChanged(this._currentWidget);\n    }\n\n    // If there is no restore data, return.\n    if (!this._restore) {\n      return;\n    }\n\n    const { state } = this._restore;\n    const name = Private.nameProperty.get(widget);\n\n    if (name) {\n      state.remove(name);\n    }\n  }\n\n  private _restore: InstanceTracker.IRestoreOptions<T> | null = null;\n  private _tracker = new FocusTracker<T>();\n  private _currentChanged = new Signal<this, T | null>(this);\n  private _widgetAdded = new Signal<this, T>(this);\n  private _widgetUpdated = new Signal<this, T>(this);\n  private _widgets: T[] = [];\n  private _currentWidget: T | null = null;\n  private _isDisposed = false;\n}\n\n/**\n * A namespace for `InstanceTracker` statics.\n */\nexport namespace InstanceTracker {\n  /**\n   * The instantiation options for an instance tracker.\n   */\n  export interface IOptions {\n    /**\n     * A namespace for all tracked widgets, (e.g., `notebook`).\n     */\n    namespace: string;\n  }\n\n  /**\n   * The state restoration configuration options.\n   */\n  export interface IRestoreOptions<T extends Widget> {\n    /**\n     * The command to execute when restoring instances.\n     */\n    command: string;\n\n    /**\n     * A function that returns the args needed to restore an instance.\n     */\n    args: (widget: T) => ReadonlyJSONObject;\n\n    /**\n     * A function that returns a unique persistent name for this instance.\n     */\n    name: (widget: T) => string;\n\n    /**\n     * The command registry which holds the restore command.\n     */\n    registry: CommandRegistry;\n\n    /**\n     * The state database instance.\n     */\n    state: IStateDB;\n\n    /**\n     * The point after which it is safe to restore state.\n     *\n     * #### Notes\n     * By definition, this promise or promises will happen after the application\n     * has `started`.\n     */\n    when?: Promise<any> | Array<Promise<any>>;\n  }\n}\n\n/*\n * A namespace for private data.\n */\nnamespace Private {\n  /**\n   * An attached property to indicate whether a widget has been injected.\n   */\n  export const injectedProperty = new AttachedProperty<Widget, boolean>({\n    name: 'injected',\n    create: () => false\n  });\n\n  /**\n   * An attached property for a widget's ID in the state database.\n   */\n  export const nameProperty = new AttachedProperty<Widget, string>({\n    name: 'name',\n    create: () => ''\n  });\n}\n"]}