{"version":3,"file":"vdom.js","sourceRoot":"","sources":["../../../../apputils/src/vdom.ts"],"names":[],"mappings":";AAAA,0CAA0C;AAC1C,2DAA2D;;;;;;;;;AAI3D,mDAA2D;AAE3D,mDAAsD;AAEtD,+CAA2C;AAI3C,oDAAsC;AAEtC;;GAEG;AACH,kBAEE,SAAQ,gBAAM;IAFhB;;QAkFU,kBAAa,GAAG,IAAI,kBAAM,CAAa,IAAI,CAAC,CAAC;IACvD,CAAC;IAhFC;;OAEG;IACH,IAAI,YAAY;QACd,OAAO,IAAI,CAAC,aAAa,CAAC;IAC5B,CAAC;IAED;;OAEG;IACH,IAAI,KAAK,CAAC,QAAkB;QAC1B,IAAI,IAAI,CAAC,MAAM,KAAK,QAAQ,EAAE;YAC5B,OAAO;SACR;QAED,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SACxD;QACD,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC;QACvB,IAAI,QAAQ,EAAE;YACZ,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SAClD;QACD,IAAI,CAAC,MAAM,EAAE,CAAC;QACd,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IAClC,CAAC;IAED;;OAEG;IACH,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAED;;OAEG;IACH,OAAO;QACL,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,KAAK,CAAC,OAAO,EAAE,CAAC;IAClB,CAAC;IAED;;;;;OAKG;IACO,eAAe,CAAC,GAAY;QACpC,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;QAC1B,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACxB,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;SACnC;aAAM;YACL,QAAQ,CAAC,MAAM,CAAM,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;SACxC;IACH,CAAC;IAED;;;OAGG;IACO,aAAa,CAAC,GAAY;QAClC,uBAAW,CAAC,WAAW,CAAC,IAAI,EAAE,gBAAM,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;IAC1D,CAAC;CAkBF;AAnFD,oCAmFC;AAED;;;;GAIG;AACH,wBAAgC,SAAQ,YAAiB;IACvD;;OAEG;IACH,YACE,EAAmE;QAEnE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;IAChB,CAAC;IAED,MAAM;QACJ,OAAO,IAAI,CAAC,GAAG,CAAC;IAClB,CAAC;CAGF;AAhBD,gDAgBC;AAiBD;;GAEG;AACH;IAAA;QACE;;WAEG;QACM,iBAAY,GAAG,IAAI,kBAAM,CAAa,IAAI,CAAC,CAAC;QAoB7C,gBAAW,GAAG,KAAK,CAAC;IAC9B,CAAC;IAnBC;;OAEG;IACH,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED;;OAEG;IACH,OAAO;QACL,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,OAAO;SACR;QACD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,kBAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACzB,CAAC;CAGF;AAzBD,8BAyBC","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { IDisposable } from '@phosphor/disposable';\n\nimport { Message, MessageLoop } from '@phosphor/messaging';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { Widget } from '@phosphor/widgets';\n\nimport * as React from 'react';\n\nimport * as ReactDOM from 'react-dom';\n\n/**\n * Phosphor widget that encodes best practices for VDOM based rendering.\n */\nexport abstract class VDomRenderer<\n  T extends VDomRenderer.IModel | null\n> extends Widget {\n  /**\n   * A signal emitted when the model changes.\n   */\n  get modelChanged(): ISignal<this, void> {\n    return this._modelChanged;\n  }\n\n  /**\n   * Set the model and fire changed signals.\n   */\n  set model(newValue: T | null) {\n    if (this._model === newValue) {\n      return;\n    }\n\n    if (this._model) {\n      this._model.stateChanged.disconnect(this.update, this);\n    }\n    this._model = newValue;\n    if (newValue) {\n      newValue.stateChanged.connect(this.update, this);\n    }\n    this.update();\n    this._modelChanged.emit(void 0);\n  }\n\n  /**\n   * Get the current model.\n   */\n  get model(): T | null {\n    return this._model;\n  }\n\n  /**\n   * Dispose this widget.\n   */\n  dispose() {\n    this._model = null;\n    super.dispose();\n  }\n\n  /**\n   * Called to update the state of the widget.\n   *\n   * The default implementation of this method triggers\n   * VDOM based rendering by calling the this.render() method.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    let vnode = this.render();\n    if (Array.isArray(vnode)) {\n      ReactDOM.render(vnode, this.node);\n    } else {\n      ReactDOM.render<any>(vnode, this.node);\n    }\n  }\n\n  /* Called after the widget is attached to the DOM\n   *\n   * Make sure the widget is rendered, even if the model has not changed.\n   */\n  protected onAfterAttach(msg: Message): void {\n    MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);\n  }\n\n  /**\n   * Render the content of this widget using the virtual DOM.\n   *\n   * This method will be called anytime the widget needs to be rendered,\n   * which includes layout triggered rendering and all model changes.\n   *\n   * Subclasses should define this method and use the current model state\n   * to create a virtual node or nodes to render.\n   */\n  protected abstract render():\n    | Array<React.ReactElement<any>>\n    | React.ReactElement<any>\n    | null;\n\n  private _model: T | null;\n  private _modelChanged = new Signal<this, void>(this);\n}\n\n/**\n * Phosphor widget that renders React Element(s).\n *\n * All messages will re-render the element.\n */\nexport class ReactElementWidget extends VDomRenderer<any> {\n  /**\n   * Creates a Phosphor widget that renders the element(s) `es`.\n   */\n  constructor(\n    es: Array<React.ReactElement<any>> | React.ReactElement<any> | null\n  ) {\n    super();\n    this._es = es;\n  }\n\n  render(): Array<React.ReactElement<any>> | React.ReactElement<any> | null {\n    return this._es;\n  }\n\n  private _es: Array<React.ReactElement<any>> | React.ReactElement<any> | null;\n}\n\n/**\n * The namespace for VDomRenderer statics.\n */\nexport namespace VDomRenderer {\n  /**\n   * An interface for a model to be used with vdom rendering.\n   */\n  export interface IModel extends IDisposable {\n    /**\n     * A signal emitted when any model state changes.\n     */\n    readonly stateChanged: ISignal<this, void>;\n  }\n}\n\n/**\n * Concrete implementation of VDomRenderer model.\n */\nexport class VDomModel implements VDomRenderer.IModel {\n  /**\n   * A signal emitted when any model state changes.\n   */\n  readonly stateChanged = new Signal<this, void>(this);\n\n  /**\n   * Test whether the model is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Dispose the model.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    Signal.clearData(this);\n  }\n\n  private _isDisposed = false;\n}\n"]}