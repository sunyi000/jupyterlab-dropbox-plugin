{"version":3,"file":"windowresolver.js","sourceRoot":"","sources":["../../../../apputils/src/windowresolver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { PromiseDelegate, Token } from '@phosphor/coreutils';\n\n/* tslint:disable */\n/**\n * The default window resolver token.\n */\nexport const IWindowResolver = new Token<IWindowResolver>(\n  '@jupyterlab/apputils:IWindowResolver'\n);\n/* tslint:enable */\n\n/**\n * The description of a window name resolver.\n */\nexport interface IWindowResolver {\n  /**\n   * A window name to use as a handle among shared resources.\n   */\n  readonly name: string;\n}\n\n/**\n * A concrete implementation of a window name resolver.\n */\nexport class WindowResolver implements IWindowResolver {\n  /**\n   * The resolved window name.\n   */\n  get name(): string {\n    return this._name;\n  }\n\n  /**\n   * Resolve a window name to use as a handle among shared resources.\n   *\n   * @param candidate - The potential window name being resolved.\n   *\n   * #### Notes\n   * Typically, the name candidate should be a JupyterLab workspace name or\n   * an empty string if there is no workspace.\n   *\n   * If the returned promise rejects, a window name cannot be resolved without\n   * user intervention, which typically means navigation to a new URL.\n   */\n  resolve(candidate: string): Promise<void> {\n    return Private.resolve(candidate).then(name => {\n      this._name = name;\n    });\n  }\n\n  private _name: string | null = null;\n}\n\n/*\n * A namespace for private module data.\n */\nnamespace Private {\n  /**\n   * The internal prefix for private local storage keys.\n   */\n  const PREFIX = '@jupyterlab/coreutils:StateDB';\n\n  /**\n   * The local storage beacon key.\n   */\n  const BEACON = `${PREFIX}:beacon`;\n\n  /**\n   * The timeout (in ms) to wait for beacon responders.\n   *\n   * #### Notes\n   * This value is a whole number between 200 and 500 in order to prevent\n   * perfect timeout collisions between multiple simultaneously opening windows\n   * that have the same URL. This is an edge case because multiple windows\n   * should not ordinarily share the same URL, but it can be contrived.\n   */\n  const TIMEOUT = Math.floor(200 + Math.random() * 300);\n\n  /**\n   * The local storage window key.\n   */\n  const WINDOW = `${PREFIX}:window`;\n\n  /**\n   * A potential preferred default window name.\n   */\n  let candidate: string | null = null;\n\n  /**\n   * The window name promise.\n   */\n  let delegate = new PromiseDelegate<string>();\n\n  /**\n   * The known window names.\n   */\n  let known: { [window: string]: null } = {};\n\n  /**\n   * The window name.\n   */\n  let name: string | null = null;\n\n  /**\n   * Whether the name resolution has completed.\n   */\n  let resolved = false;\n\n  /**\n   * Start the storage event handler.\n   */\n  function initialize(): void {\n    // Listen to all storage events for beacons and window names.\n    window.addEventListener('storage', (event: StorageEvent) => {\n      const { key, newValue } = event;\n\n      // All the keys we care about have values.\n      if (newValue === null) {\n        return;\n      }\n\n      // If the beacon was fired, respond with a ping.\n      if (key === BEACON && candidate !== null) {\n        ping(resolved ? name : candidate);\n        return;\n      }\n\n      // If the window name is resolved, bail.\n      if (resolved || key !== WINDOW) {\n        return;\n      }\n\n      const reported = newValue.replace(/\\-\\d+$/, '');\n\n      // Store the reported window name.\n      known[reported] = null;\n\n      // If a reported window name and candidate collide, reject the candidate.\n      if (candidate in known) {\n        reject();\n      }\n    });\n  }\n\n  /**\n   * Ping peers with payload.\n   */\n  function ping(payload: string): void {\n    if (payload === null) {\n      return;\n    }\n\n    const { localStorage } = window;\n\n    localStorage.setItem(WINDOW, `${payload}-${new Date().getTime()}`);\n  }\n\n  /**\n   * Reject the candidate.\n   */\n  function reject(): void {\n    resolved = true;\n    delegate.reject(`Window name candidate \"${candidate}\" already exists`);\n  }\n\n  /**\n   * Returns a promise that resolves with the window name used for restoration.\n   */\n  export function resolve(potential: string): Promise<string> {\n    if (resolved) {\n      return delegate.promise;\n    }\n\n    // Set the local candidate.\n    candidate = potential;\n\n    if (candidate in known) {\n      reject();\n      return delegate.promise;\n    }\n\n    const { localStorage, setTimeout } = window;\n\n    // Wait until other windows have reported before claiming the candidate.\n    setTimeout(() => {\n      if (resolved) {\n        return;\n      }\n\n      // If the window name has not already been resolved, check one last time\n      // to confirm it is not a duplicate before resolving.\n      if (candidate in known) {\n        return reject();\n      }\n\n      resolved = true;\n      delegate.resolve((name = candidate));\n      ping(name);\n    }, TIMEOUT);\n\n    // Fire the beacon to collect other windows' names.\n    localStorage.setItem(BEACON, `${Math.random()}-${new Date().getTime()}`);\n\n    return delegate.promise;\n  }\n\n  // Initialize the storage listener at runtime.\n  (() => {\n    initialize();\n  })();\n}\n"]}