{"version":3,"file":"observablestring.js","sourceRoot":"","sources":["../../../../observables/src/observablestring.ts"],"names":[],"mappings":";AAAA,0CAA0C;AAC1C,2DAA2D;;AAI3D,mDAAsD;AA+GtD;;GAEG;AACH;IACE;;OAEG;IACH,YAAY,cAAsB,EAAE;QAsG5B,UAAK,GAAG,EAAE,CAAC;QACX,gBAAW,GAAY,KAAK,CAAC;QAC7B,aAAQ,GAAG,IAAI,kBAAM,CAAuC,IAAI,CAAC,CAAC;QAvGxE,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC;IAC3B,CAAC;IAED;;OAEG;IACH,IAAI,IAAI;QACN,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED;;OAEG;IACH,IAAI,OAAO;QACT,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED;;OAEG;IACH,IAAI,IAAI,CAAC,KAAa;QACpB,IAAI,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,KAAK,KAAK,IAAI,CAAC,KAAK,EAAE;YAC9D,OAAO;SACR;QACD,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC;YACjB,IAAI,EAAE,KAAK;YACX,KAAK,EAAE,CAAC;YACR,GAAG,EAAE,KAAK,CAAC,MAAM;YACjB,KAAK,EAAE,KAAK;SACb,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACH,IAAI,IAAI;QACN,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,KAAa,EAAE,IAAY;QAChC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACzE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC;YACjB,IAAI,EAAE,QAAQ;YACd,KAAK,EAAE,KAAK;YACZ,GAAG,EAAE,KAAK,GAAG,IAAI,CAAC,MAAM;YACxB,KAAK,EAAE,IAAI;SACZ,CAAC,CAAC;IACL,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,KAAa,EAAE,GAAW;QAC/B,IAAI,QAAQ,GAAW,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QACpD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAChE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC;YACjB,IAAI,EAAE,QAAQ;YACd,KAAK,EAAE,KAAK;YACZ,GAAG,EAAE,GAAG;YACR,KAAK,EAAE,QAAQ;SAChB,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACH,KAAK;QACH,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;IACjB,CAAC;IAED;;OAEG;IACH,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED;;OAEG;IACH,OAAO;QACL,IAAI,IAAI,CAAC,WAAW,EAAE;YACpB,OAAO;SACR;QACD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,kBAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACvB,IAAI,CAAC,KAAK,EAAE,CAAC;IACf,CAAC;CAKF;AA7GD,4CA6GC","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { IDisposable } from '@phosphor/disposable';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { IObservable } from './modeldb';\n\n/**\n * A string which can be observed for changes.\n */\nexport interface IObservableString extends IDisposable, IObservable {\n  /**\n   * The type of the Observable.\n   */\n  type: 'String';\n\n  /**\n   * A signal emitted when the string has changed.\n   */\n  readonly changed: ISignal<this, IObservableString.IChangedArgs>;\n\n  /**\n   * The value of the string.\n   */\n  text: string;\n\n  /**\n   * Insert a substring.\n   *\n   * @param index - The starting index.\n   *\n   * @param text - The substring to insert.\n   */\n  insert(index: number, text: string): void;\n\n  /**\n   * Remove a substring.\n   *\n   * @param start - The starting index.\n   *\n   * @param end - The ending index.\n   */\n  remove(start: number, end: number): void;\n\n  /**\n   * Set the ObservableString to an empty string.\n   */\n  clear(): void;\n\n  /**\n   * Dispose of the resources held by the string.\n   */\n  dispose(): void;\n}\n\n/**\n * The namespace for `IObservableString` associate interfaces.\n */\nexport namespace IObservableString {\n  /**\n   * The change types which occur on an observable string.\n   */\n  export type ChangeType =\n    /**\n     * Text was inserted.\n     */\n    | 'insert'\n\n    /**\n     * Text was removed.\n     */\n    | 'remove'\n\n    /**\n     * Text was set.\n     */\n    | 'set';\n\n  /**\n   * The changed args object which is emitted by an observable string.\n   */\n  export interface IChangedArgs {\n    /**\n     * The type of change undergone by the list.\n     */\n    type: ChangeType;\n\n    /**\n     * The starting index of the change.\n     */\n    start: number;\n\n    /**\n     * The end index of the change.\n     */\n    end: number;\n\n    /**\n     * The value of the change.\n     *\n     * ### Notes\n     * If `ChangeType` is `set`, then\n     * this is the new value of the string.\n     *\n     * If `ChangeType` is `insert` this is\n     * the value of the inserted string.\n     *\n     * If `ChangeType` is remove this is the\n     * value of the removed substring.\n     */\n    value: string;\n  }\n}\n\n/**\n * A concrete implementation of [[IObservableString]]\n */\nexport class ObservableString implements IObservableString {\n  /**\n   * Construct a new observable string.\n   */\n  constructor(initialText: string = '') {\n    this._text = initialText;\n  }\n\n  /**\n   * The type of the Observable.\n   */\n  get type(): 'String' {\n    return 'String';\n  }\n\n  /**\n   * A signal emitted when the string has changed.\n   */\n  get changed(): ISignal<this, IObservableString.IChangedArgs> {\n    return this._changed;\n  }\n\n  /**\n   * Set the value of the string.\n   */\n  set text(value: string) {\n    if (value.length === this._text.length && value === this._text) {\n      return;\n    }\n    this._text = value;\n    this._changed.emit({\n      type: 'set',\n      start: 0,\n      end: value.length,\n      value: value\n    });\n  }\n\n  /**\n   * Get the value of the string.\n   */\n  get text(): string {\n    return this._text;\n  }\n\n  /**\n   * Insert a substring.\n   *\n   * @param index - The starting index.\n   *\n   * @param text - The substring to insert.\n   */\n  insert(index: number, text: string): void {\n    this._text = this._text.slice(0, index) + text + this._text.slice(index);\n    this._changed.emit({\n      type: 'insert',\n      start: index,\n      end: index + text.length,\n      value: text\n    });\n  }\n\n  /**\n   * Remove a substring.\n   *\n   * @param start - The starting index.\n   *\n   * @param end - The ending index.\n   */\n  remove(start: number, end: number): void {\n    let oldValue: string = this._text.slice(start, end);\n    this._text = this._text.slice(0, start) + this._text.slice(end);\n    this._changed.emit({\n      type: 'remove',\n      start: start,\n      end: end,\n      value: oldValue\n    });\n  }\n\n  /**\n   * Set the ObservableString to an empty string.\n   */\n  clear(): void {\n    this.text = '';\n  }\n\n  /**\n   * Test whether the string has been disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Dispose of the resources held by the string.\n   */\n  dispose(): void {\n    if (this._isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    Signal.clearData(this);\n    this.clear();\n  }\n\n  private _text = '';\n  private _isDisposed: boolean = false;\n  private _changed = new Signal<this, IObservableString.IChangedArgs>(this);\n}\n"]}