{"version":3,"file":"editor.js","sourceRoot":"","sources":["../../../../codeeditor/src/editor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { JSONObject } from '@phosphor/coreutils';\n\nimport { IDisposable } from '@phosphor/disposable';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { IChangedArgs } from '@jupyterlab/coreutils';\n\nimport {\n  IModelDB,\n  ModelDB,\n  IObservableValue,\n  ObservableValue,\n  IObservableMap,\n  IObservableString\n} from '@jupyterlab/observables';\n\n/**\n * A namespace for code editors.\n *\n * #### Notes\n * - A code editor is a set of common assumptions which hold for all concrete editors.\n * - Changes in implementations of the code editor should only be caused by changes in concrete editors.\n * - Common JLab services which are based on the code editor should belong to `IEditorServices`.\n */\nexport namespace CodeEditor {\n  /**\n   * A zero-based position in the editor.\n   */\n  export interface IPosition extends JSONObject {\n    /**\n     * The cursor line number.\n     */\n    readonly line: number;\n\n    /**\n     * The cursor column number.\n     */\n    readonly column: number;\n  }\n\n  /**\n   * The dimension of an element.\n   */\n  export interface IDimension {\n    /**\n     * The width of an element in pixels.\n     */\n    readonly width: number;\n\n    /**\n     * The height of an element in pixels.\n     */\n    readonly height: number;\n  }\n\n  /**\n   * An interface describing editor state coordinates.\n   */\n  export interface ICoordinate extends JSONObject, ClientRect {}\n\n  /**\n   * A range.\n   */\n  export interface IRange extends JSONObject {\n    /**\n     * The position of the first character in the current range.\n     *\n     * #### Notes\n     * If this position is greater than [end] then the range is considered\n     * to be backward.\n     */\n    readonly start: IPosition;\n\n    /**\n     * The position of the last character in the current range.\n     *\n     * #### Notes\n     * If this position is less than [start] then the range is considered\n     * to be backward.\n     */\n    readonly end: IPosition;\n  }\n\n  /**\n   * A selection style.\n   */\n  export interface ISelectionStyle extends JSONObject {\n    /**\n     * A class name added to a selection.\n     */\n    className: string;\n\n    /**\n     * A display name added to a selection.\n     */\n    displayName: string;\n\n    /**\n     * A color for UI elements.\n     */\n    color: string;\n  }\n\n  /**\n   * The default selection style.\n   */\n  export const defaultSelectionStyle: ISelectionStyle = {\n    className: '',\n    displayName: '',\n    color: 'black'\n  };\n\n  /**\n   * A text selection.\n   */\n  export interface ITextSelection extends IRange {\n    /**\n     * The uuid of the text selection owner.\n     */\n    readonly uuid: string;\n\n    /**\n     * The style of this selection.\n     */\n    readonly style: ISelectionStyle;\n  }\n\n  /**\n   * An interface for a text token, such as a word, keyword, or variable.\n   */\n  export interface IToken {\n    /**\n     * The value of the token.\n     */\n    value: string;\n\n    /**\n     * The offset of the token in the code editor.\n     */\n    offset: number;\n\n    /**\n     * An optional type for the token.\n     */\n    type?: string;\n  }\n\n  /**\n   * An interface to manage selections by selection owners.\n   *\n   * #### Definitions\n   * - a user code that has an associated uuid is called a selection owner, see `CodeEditor.ISelectionOwner`\n   * - a selection belongs to a selection owner only if it is associated with the owner by an uuid, see `CodeEditor.ITextSelection`\n   *\n   * #### Read access\n   * - any user code can observe any selection\n   *\n   * #### Write access\n   * - if a user code is a selection owner then:\n   *   - it can change selections belonging to it\n   *   - but it must not change selections belonging to other selection owners\n   * - otherwise it must not change any selection\n   */\n\n  /**\n   * An editor model.\n   */\n  export interface IModel extends IDisposable {\n    /**\n     * A signal emitted when a property changes.\n     */\n    mimeTypeChanged: ISignal<IModel, IChangedArgs<string>>;\n\n    /**\n     * The text stored in the model.\n     */\n    readonly value: IObservableString;\n\n    /**\n     * A mime type of the model.\n     *\n     * #### Notes\n     * It is never `null`, the default mime type is `text/plain`.\n     */\n    mimeType: string;\n\n    /**\n     * The currently selected code.\n     */\n    readonly selections: IObservableMap<ITextSelection[]>;\n\n    /**\n     * The underlying `IModelDB` instance in which model\n     * data is stored.\n     */\n    readonly modelDB: IModelDB;\n  }\n\n  /**\n   * The default implementation of the editor model.\n   */\n  export class Model implements IModel {\n    /**\n     * Construct a new Model.\n     */\n    constructor(options?: Model.IOptions) {\n      options = options || {};\n\n      if (options.modelDB) {\n        this.modelDB = options.modelDB;\n      } else {\n        this.modelDB = new ModelDB();\n      }\n\n      let value = this.modelDB.createString('value');\n      value.text = value.text || options.value || '';\n\n      let mimeType = this.modelDB.createValue('mimeType');\n      mimeType.set(options.mimeType || 'text/plain');\n      mimeType.changed.connect(this._onMimeTypeChanged, this);\n\n      this.modelDB.createMap('selections');\n    }\n\n    /**\n     * The underlying `IModelDB` instance in which model\n     * data is stored.\n     */\n    readonly modelDB: IModelDB;\n\n    /**\n     * A signal emitted when a mimetype changes.\n     */\n    get mimeTypeChanged(): ISignal<this, IChangedArgs<string>> {\n      return this._mimeTypeChanged;\n    }\n\n    /**\n     * Get the value of the model.\n     */\n    get value(): IObservableString {\n      return this.modelDB.get('value') as IObservableString;\n    }\n\n    /**\n     * Get the selections for the model.\n     */\n    get selections(): IObservableMap<ITextSelection[]> {\n      return this.modelDB.get('selections') as IObservableMap<ITextSelection[]>;\n    }\n\n    /**\n     * A mime type of the model.\n     */\n    get mimeType(): string {\n      return this.modelDB.getValue('mimeType') as string;\n    }\n    set mimeType(newValue: string) {\n      const oldValue = this.mimeType;\n      if (oldValue === newValue) {\n        return;\n      }\n      this.modelDB.setValue('mimeType', newValue);\n    }\n\n    /**\n     * Whether the model is disposed.\n     */\n    get isDisposed(): boolean {\n      return this._isDisposed;\n    }\n\n    /**\n     * Dispose of the resources used by the model.\n     */\n    dispose(): void {\n      if (this._isDisposed) {\n        return;\n      }\n      this._isDisposed = true;\n      Signal.clearData(this);\n    }\n\n    private _onMimeTypeChanged(\n      mimeType: IObservableValue,\n      args: ObservableValue.IChangedArgs\n    ): void {\n      this._mimeTypeChanged.emit({\n        name: 'mimeType',\n        oldValue: args.oldValue as string,\n        newValue: args.newValue as string\n      });\n    }\n\n    private _isDisposed = false;\n    private _mimeTypeChanged = new Signal<this, IChangedArgs<string>>(this);\n  }\n\n  /**\n   * A selection owner.\n   */\n  export interface ISelectionOwner {\n    /**\n     * The uuid of this selection owner.\n     */\n    uuid: string;\n\n    /**\n     * Returns the primary position of the cursor, never `null`.\n     */\n    getCursorPosition(): IPosition;\n\n    /**\n     * Set the primary position of the cursor.\n     *\n     * @param position - The new primary position.\n     *\n     * #### Notes\n     * This will remove any secondary cursors.\n     */\n    setCursorPosition(position: IPosition): void;\n\n    /**\n     * Returns the primary selection, never `null`.\n     */\n    getSelection(): IRange;\n\n    /**\n     * Set the primary selection.\n     *\n     * @param selection - The desired selection range.\n     *\n     * #### Notes\n     * This will remove any secondary cursors.\n     */\n    setSelection(selection: IRange): void;\n\n    /**\n     * Gets the selections for all the cursors, never `null` or empty.\n     */\n    getSelections(): IRange[];\n\n    /**\n     * Sets the selections for all the cursors.\n     *\n     * @param selections - The new selections.\n     *\n     * #### Notes\n     * Cursors will be removed or added, as necessary.\n     * Passing an empty array resets a cursor position to the start of a\n     * document.\n     */\n    setSelections(selections: IRange[]): void;\n  }\n\n  /**\n   * A keydown handler type.\n   *\n   * #### Notes\n   * Return `true` to prevent the default handling of the event by the\n   * editor.\n   */\n  export type KeydownHandler = (\n    instance: IEditor,\n    event: KeyboardEvent\n  ) => boolean;\n\n  /**\n   * The location of requested edges.\n   */\n  export type EdgeLocation = 'top' | 'bottom';\n\n  /**\n   * A widget that provides a code editor.\n   */\n  export interface IEditor extends ISelectionOwner, IDisposable {\n    /**\n     * A signal emitted when either the top or bottom edge is requested.\n     */\n    readonly edgeRequested: ISignal<IEditor, EdgeLocation>;\n\n    /**\n     * The default selection style for the editor.\n     */\n    selectionStyle: CodeEditor.ISelectionStyle;\n\n    /**\n     * The DOM node that hosts the editor.\n     */\n    readonly host: HTMLElement;\n\n    /**\n     * The model used by the editor.\n     */\n    readonly model: IModel;\n\n    /**\n     * The height of a line in the editor in pixels.\n     */\n    readonly lineHeight: number;\n\n    /**\n     * The widget of a character in the editor in pixels.\n     */\n    readonly charWidth: number;\n\n    /**\n     * Get the number of lines in the eidtor.\n     */\n    readonly lineCount: number;\n\n    /**\n     * Get a config option for the editor.\n     */\n    getOption<K extends keyof IConfig>(option: K): IConfig[K];\n\n    /**\n     * Set a config option for the editor.\n     */\n    setOption<K extends keyof IConfig>(option: K, value: IConfig[K]): void;\n\n    /**\n     * Returns the content for the given line number.\n     *\n     * @param line - The line of interest.\n     *\n     * @returns The value of the line.\n     *\n     * #### Notes\n     * Lines are 0-based, and accessing a line out of range returns\n     * `undefined`.\n     */\n    getLine(line: number): string | undefined;\n\n    /**\n     * Find an offset for the given position.\n     *\n     * @param position - The position of interest.\n     *\n     * @returns The offset at the position, clamped to the extent of the\n     * editor contents.\n     */\n    getOffsetAt(position: IPosition): number;\n\n    /**\n     * Find a position for the given offset.\n     *\n     * @param offset - The offset of interest.\n     *\n     * @returns The position at the offset, clamped to the extent of the\n     * editor contents.\n     */\n    getPositionAt(offset: number): IPosition | undefined;\n\n    /**\n     * Undo one edit (if any undo events are stored).\n     */\n    undo(): void;\n\n    /**\n     * Redo one undone edit.\n     */\n    redo(): void;\n\n    /**\n     * Clear the undo history.\n     */\n    clearHistory(): void;\n\n    /**\n     * Brings browser focus to this editor text.\n     */\n    focus(): void;\n\n    /**\n     * Test whether the editor has keyboard focus.\n     */\n    hasFocus(): boolean;\n\n    /**\n     * Explicitly blur the editor.\n     */\n    blur(): void;\n\n    /**\n     * Repaint the editor.\n     *\n     * #### Notes\n     * A repainted editor should fit to its host node.\n     */\n    refresh(): void;\n\n    /**\n     * Resize the editor to fit its host node.\n     */\n    resizeToFit(): void;\n\n    /**\n     * Add a keydown handler to the editor.\n     *\n     * @param handler - A keydown handler.\n     *\n     * @returns A disposable that can be used to remove the handler.\n     */\n    addKeydownHandler(handler: KeydownHandler): IDisposable;\n\n    /**\n     * Set the size of the editor.\n     *\n     * @param size - The desired size.\n     *\n     * #### Notes\n     * Use `null` if the size is unknown.\n     */\n    setSize(size: IDimension | null): void;\n\n    /**\n     * Reveals the given position in the editor.\n     *\n     * @param position - The desired position to reveal.\n     */\n    revealPosition(position: IPosition): void;\n\n    /**\n     * Reveals the given selection in the editor.\n     *\n     * @param position - The desired selection to reveal.\n     */\n    revealSelection(selection: IRange): void;\n\n    /**\n     * Get the window coordinates given a cursor position.\n     *\n     * @param position - The desired position.\n     *\n     * @returns The coordinates of the position.\n     */\n    getCoordinateForPosition(position: IPosition): ICoordinate;\n\n    /**\n     * Get the cursor position given window coordinates.\n     *\n     * @param coordinate - The desired coordinate.\n     *\n     * @returns The position of the coordinates, or null if not\n     *   contained in the editor.\n     */\n    getPositionForCoordinate(coordinate: ICoordinate): IPosition | null;\n\n    /**\n     * Inserts a new line at the cursor position and indents it.\n     */\n    newIndentedLine(): void;\n\n    /**\n     * Gets the token at a given position.\n     */\n    getTokenForPosition(position: IPosition): IToken;\n\n    /**\n     * Gets the list of tokens for the editor model.\n     */\n    getTokens(): IToken[];\n  }\n\n  /**\n   * A factory used to create a code editor.\n   */\n  export type Factory = (options: IOptions) => CodeEditor.IEditor;\n\n  /**\n   * The configuration options for an editor.\n   */\n  export interface IConfig {\n    /**\n     * User preferred font family for text editors.\n     */\n    fontFamily: string | null;\n\n    /**\n     * User preferred size in pixel of the font used in text editors.\n     */\n    fontSize: number | null;\n\n    /**\n     * User preferred text line height, as a multiplier of font size.\n     */\n    lineHeight: number | null;\n\n    /**\n     * Whether line numbers should be displayed.\n     */\n    lineNumbers: boolean;\n\n    /**\n     * Control the line wrapping of the editor. Possible values are:\n     * - \"off\", lines will never wrap.\n     * - \"on\", lines will wrap at the viewport border.\n     * - \"wordWrapColumn\", lines will wrap at `wordWrapColumn`.\n     * - \"bounded\", lines will wrap at minimum between viewport width and wordWrapColumn.\n     */\n    lineWrap: 'off' | 'on' | 'wordWrapColumn' | 'bounded';\n\n    /**\n     * Whether the editor is read-only.\n     */\n    readOnly: boolean;\n\n    /**\n     * The number of spaces a tab is equal to.\n     */\n    tabSize: number;\n\n    /**\n     * Whether to insert spaces when pressing Tab.\n     */\n    insertSpaces: boolean;\n\n    /**\n     * Whether to highlight matching brackets when one of them is selected.\n     */\n    matchBrackets: boolean;\n\n    /**\n     * Whether to automatically close brackets after opening them.\n     */\n    autoClosingBrackets: boolean;\n\n    /**\n     * The column where to break text line.\n     */\n    wordWrapColumn: number;\n  }\n\n  /**\n   * The default configuration options for an editor.\n   */\n  export let defaultConfig: IConfig = {\n    fontFamily: null,\n    fontSize: null,\n    lineHeight: null,\n    lineNumbers: false,\n    lineWrap: 'on',\n    wordWrapColumn: 80,\n    readOnly: false,\n    tabSize: 4,\n    insertSpaces: true,\n    matchBrackets: true,\n    autoClosingBrackets: true\n  };\n\n  /**\n   * The options used to initialize an editor.\n   */\n  export interface IOptions {\n    /**\n     * The host widget used by the editor.\n     */\n    host: HTMLElement;\n\n    /**\n     * The model used by the editor.\n     */\n    model: IModel;\n\n    /**\n     * The desired uuid for the editor.\n     */\n    uuid?: string;\n\n    /**\n     * The default selection style for the editor.\n     */\n    selectionStyle?: Partial<CodeEditor.ISelectionStyle>;\n\n    /**\n     * The configuration options for the editor.\n     */\n    config?: Partial<IConfig>;\n  }\n\n  export namespace Model {\n    export interface IOptions {\n      /**\n       * The initial value of the model.\n       */\n      value?: string;\n\n      /**\n       * The mimetype of the model.\n       */\n      mimeType?: string;\n\n      /**\n       * An optional modelDB for storing model state.\n       */\n      modelDB?: IModelDB;\n    }\n  }\n}\n"]}