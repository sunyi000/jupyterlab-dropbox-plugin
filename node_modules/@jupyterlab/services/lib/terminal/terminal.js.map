{"version":3,"file":"terminal.js","sourceRoot":"","sources":["../../../../../services/src/terminal/terminal.ts"],"names":[],"mappings":";AAAA,0CAA0C;AAC1C,2DAA2D;;AAY3D,uCAAmD;AAEnD;;GAEG;AACH,IAAiB,eAAe,CA6Q/B;AA7QD,WAAiB,eAAe;IA0D9B;;OAEG;IACH;QACE,OAAO,gCAAsB,CAAC,WAAW,EAAE,CAAC;IAC9C,CAAC;IAFe,2BAAW,cAE1B,CAAA;IAED;;;;;;OAMG;IACH,kBAAyB,OAAkB;QACzC,OAAO,gCAAsB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IAClD,CAAC;IAFe,wBAAQ,WAEvB,CAAA;IAED;;;;;;;;;;;;;;;;;OAiBG;IACH,mBACE,IAAY,EACZ,OAAkB;QAElB,OAAO,gCAAsB,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACzD,CAAC;IALe,yBAAS,YAKxB,CAAA;IAED;;;;;;OAMG;IACH,qBACE,QAAqC;QAErC,OAAO,gCAAsB,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IACtD,CAAC;IAJe,2BAAW,cAI1B,CAAA;IAED;;;;;;;;OAQG;IACH,kBACE,IAAY,EACZ,QAAqC;QAErC,OAAO,gCAAsB,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IACzD,CAAC;IALe,wBAAQ,WAKvB,CAAA;IAED;;;;OAIG;IACH,qBACE,QAAqC;QAErC,OAAO,gCAAsB,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IACtD,CAAC;IAJe,2BAAW,cAI1B,CAAA;AAkIH,CAAC,EA7QgB,eAAe,GAAf,uBAAe,KAAf,uBAAe,QA6Q/B","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { IIterator } from '@phosphor/algorithm';\n\nimport { JSONPrimitive, JSONObject } from '@phosphor/coreutils';\n\nimport { IDisposable } from '@phosphor/disposable';\n\nimport { ISignal } from '@phosphor/signaling';\n\nimport { ServerConnection } from '..';\n\nimport { DefaultTerminalSession } from './default';\n\n/**\n * The namespace for ISession statics.\n */\nexport namespace TerminalSession {\n  /**\n   * An interface for a terminal session.\n   */\n  export interface ISession extends IDisposable {\n    /**\n     * A signal emitted when the session is shut down.\n     */\n    terminated: ISignal<ISession, void>;\n\n    /**\n     * A signal emitted when a message is received from the server.\n     */\n    messageReceived: ISignal<ISession, IMessage>;\n\n    /**\n     * Get the name of the terminal session.\n     */\n    readonly name: string;\n\n    /**\n     * The model associated with the session.\n     */\n    readonly model: IModel;\n\n    /**\n     * The server settings for the session.\n     */\n    readonly serverSettings: ServerConnection.ISettings;\n\n    /**\n     * Test whether the session is ready.\n     */\n    readonly isReady: boolean;\n\n    /**\n     * A promise that fulfills when the session is initially ready.\n     */\n    readonly ready: Promise<void>;\n\n    /**\n     * Send a message to the terminal session.\n     */\n    send(message: IMessage): void;\n\n    /**\n     * Reconnect to the terminal.\n     *\n     * @returns A promise that resolves when the terminal has reconnected.\n     */\n    reconnect(): Promise<void>;\n\n    /**\n     * Shut down the terminal session.\n     */\n    shutdown(): Promise<void>;\n  }\n\n  /**\n   * Test whether the terminal service is available.\n   */\n  export function isAvailable(): boolean {\n    return DefaultTerminalSession.isAvailable();\n  }\n\n  /**\n   * Start a new terminal session.\n   *\n   * @param options - The session options to use.\n   *\n   * @returns A promise that resolves with the session instance.\n   */\n  export function startNew(options?: IOptions): Promise<ISession> {\n    return DefaultTerminalSession.startNew(options);\n  }\n\n  /*\n   * Connect to a running session.\n   *\n   * @param name - The name of the target session.\n   *\n   * @param options - The session options to use.\n   *\n   * @returns A promise that resolves with the new session instance.\n   *\n   * #### Notes\n   * If the session was already started via `startNew`, the existing\n   * session object is used as the fulfillment value.\n   *\n   * Otherwise, if `options` are given, we resolve the promise after\n   * confirming that the session exists on the server.\n   *\n   * If the session does not exist on the server, the promise is rejected.\n   */\n  export function connectTo(\n    name: string,\n    options?: IOptions\n  ): Promise<ISession> {\n    return DefaultTerminalSession.connectTo(name, options);\n  }\n\n  /**\n   * List the running terminal sessions.\n   *\n   * @param settings - The server settings to use.\n   *\n   * @returns A promise that resolves with the list of running session models.\n   */\n  export function listRunning(\n    settings?: ServerConnection.ISettings\n  ): Promise<IModel[]> {\n    return DefaultTerminalSession.listRunning(settings);\n  }\n\n  /**\n   * Shut down a terminal session by name.\n   *\n   * @param name - The name of the target session.\n   *\n   * @param settings - The server settings to use.\n   *\n   * @returns A promise that resolves when the session is shut down.\n   */\n  export function shutdown(\n    name: string,\n    settings?: ServerConnection.ISettings\n  ): Promise<void> {\n    return DefaultTerminalSession.shutdown(name, settings);\n  }\n\n  /**\n   * Shut down all terminal sessions.\n   *\n   * @returns A promise that resolves when all of the sessions are shut down.\n   */\n  export function shutdownAll(\n    settings?: ServerConnection.ISettings\n  ): Promise<void> {\n    return DefaultTerminalSession.shutdownAll(settings);\n  }\n\n  /**\n   * The options for initializing a terminal session object.\n   */\n  export interface IOptions {\n    /**\n     * The server settings for the session.\n     */\n    serverSettings?: ServerConnection.ISettings;\n  }\n\n  /**\n   * The server model for a terminal session.\n   */\n  export interface IModel extends JSONObject {\n    /**\n     * The name of the terminal session.\n     */\n    readonly name: string;\n  }\n\n  /**\n   * A message from the terminal session.\n   */\n  export interface IMessage {\n    /**\n     * The type of the message.\n     */\n    readonly type: MessageType;\n\n    /**\n     * The content of the message.\n     */\n    readonly content?: JSONPrimitive[];\n  }\n\n  /**\n   * Valid message types for the terminal.\n   */\n  export type MessageType = 'stdout' | 'disconnect' | 'set_size' | 'stdin';\n\n  /**\n   * The interface for a terminal manager.\n   *\n   * #### Notes\n   * The manager is responsible for maintaining the state of running\n   * terminal sessions.\n   */\n  export interface IManager extends IDisposable {\n    /**\n     * A signal emitted when the running terminals change.\n     */\n    runningChanged: ISignal<IManager, IModel[]>;\n\n    /**\n     * The server settings for the manager.\n     */\n    readonly serverSettings: ServerConnection.ISettings;\n\n    /**\n     * Test whether the manager is ready.\n     */\n    readonly isReady: boolean;\n\n    /**\n     * A promise that fulfills when the manager is ready.\n     */\n    readonly ready: Promise<void>;\n\n    /**\n     * Whether the terminal service is available.\n     */\n    isAvailable(): boolean;\n\n    /**\n     * Create an iterator over the known running terminals.\n     *\n     * @returns A new iterator over the running terminals.\n     */\n    running(): IIterator<IModel>;\n\n    /**\n     * Create a new terminal session.\n     *\n     * @param options - The options used to create the session.\n     *\n     * @returns A promise that resolves with the terminal instance.\n     *\n     * #### Notes\n     * The manager `serverSettings` will be always be used.\n     */\n    startNew(options?: IOptions): Promise<ISession>;\n\n    /*\n     * Connect to a running session.\n     *\n     * @param name - The name of the target session.\n     *\n     * @returns A promise that resolves with the new session instance.\n     */\n    connectTo(name: string): Promise<ISession>;\n\n    /**\n     * Shut down a terminal session by name.\n     *\n     * @param name - The name of the terminal session.\n     *\n     * @returns A promise that resolves when the session is shut down.\n     */\n    shutdown(name: string): Promise<void>;\n\n    /**\n     * Shut down all terminal sessions.\n     *\n     * @returns A promise that resolves when all of the sessions are shut down.\n     */\n    shutdownAll(): Promise<void>;\n\n    /**\n     * Force a refresh of the running terminal sessions.\n     *\n     * @returns A promise that with the list of running sessions.\n     *\n     * #### Notes\n     * This is not typically meant to be called by the user, since the\n     * manager maintains its own internal state.\n     */\n    refreshRunning(): Promise<void>;\n  }\n}\n"]}