{"version":3,"file":"comm.js","sourceRoot":"","sources":["../../../../../services/src/kernel/comm.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { JSONObject, JSONValue } from '@phosphor/coreutils';\n\nimport { DisposableDelegate } from '@phosphor/disposable';\n\nimport { Kernel } from './kernel';\n\nimport { KernelMessage } from './messages';\n\n/**\n * Comm channel handler.\n */\nexport class CommHandler extends DisposableDelegate implements Kernel.IComm {\n  /**\n   * Construct a new comm channel.\n   */\n  constructor(\n    target: string,\n    id: string,\n    kernel: Kernel.IKernel,\n    disposeCb: () => void\n  ) {\n    super(disposeCb);\n    this._id = id;\n    this._target = target;\n    this._kernel = kernel;\n  }\n\n  /**\n   * The unique id for the comm channel.\n   */\n  get commId(): string {\n    return this._id;\n  }\n\n  /**\n   * The target name for the comm channel.\n   */\n  get targetName(): string {\n    return this._target;\n  }\n\n  /**\n   * Get the callback for a comm close event.\n   *\n   * #### Notes\n   * This is called when the comm is closed from either the server or client.\n   *\n   * **See also:** [[ICommClose]], [[close]]\n   */\n  get onClose(): (\n    msg: KernelMessage.ICommCloseMsg\n  ) => void | PromiseLike<void> {\n    return this._onClose;\n  }\n\n  /**\n   * Set the callback for a comm close event.\n   *\n   * #### Notes\n   * This is called when the comm is closed from either the server or client. If\n   * the function returns a promise, and the kernel was closed from the server,\n   * kernel message processing will pause until the returned promise is\n   * fulfilled.\n   *\n   * **See also:** [[close]]\n   */\n  set onClose(\n    cb: (msg: KernelMessage.ICommCloseMsg) => void | PromiseLike<void>\n  ) {\n    this._onClose = cb;\n  }\n\n  /**\n   * Get the callback for a comm message received event.\n   */\n  get onMsg(): (msg: KernelMessage.ICommMsgMsg) => void | PromiseLike<void> {\n    return this._onMsg;\n  }\n\n  /**\n   * Set the callback for a comm message received event.\n   *\n   * #### Notes\n   * This is called when a comm message is received. If the function returns a\n   * promise, kernel message processing will pause until it is fulfilled.\n   */\n  set onMsg(cb: (msg: KernelMessage.ICommMsgMsg) => void | PromiseLike<void>) {\n    this._onMsg = cb;\n  }\n\n  /**\n   * Open a comm with optional data and metadata.\n   *\n   * #### Notes\n   * This sends a `comm_open` message to the server.\n   *\n   * **See also:** [[ICommOpen]]\n   */\n  open(\n    data?: JSONValue,\n    metadata?: JSONObject,\n    buffers: (ArrayBuffer | ArrayBufferView)[] = []\n  ): Kernel.IFuture {\n    if (this.isDisposed || this._kernel.isDisposed) {\n      throw new Error('Cannot open');\n    }\n    let options: KernelMessage.IOptions = {\n      msgType: 'comm_open',\n      channel: 'shell',\n      username: this._kernel.username,\n      session: this._kernel.clientId\n    };\n    let content: KernelMessage.ICommOpen = {\n      comm_id: this._id,\n      target_name: this._target,\n      data: data || {}\n    };\n    let msg = KernelMessage.createShellMessage(\n      options,\n      content,\n      metadata,\n      buffers\n    );\n    return this._kernel.sendShellMessage(msg, false, true);\n  }\n\n  /**\n   * Send a `comm_msg` message to the kernel.\n   *\n   * #### Notes\n   * This is a no-op if the comm has been closed.\n   *\n   * **See also:** [[ICommMsg]]\n   */\n  send(\n    data: JSONValue,\n    metadata?: JSONObject,\n    buffers: (ArrayBuffer | ArrayBufferView)[] = [],\n    disposeOnDone: boolean = true\n  ): Kernel.IFuture {\n    if (this.isDisposed || this._kernel.isDisposed) {\n      throw new Error('Cannot send');\n    }\n    let options: KernelMessage.IOptions = {\n      msgType: 'comm_msg',\n      channel: 'shell',\n      username: this._kernel.username,\n      session: this._kernel.clientId\n    };\n    let content: KernelMessage.ICommMsg = {\n      comm_id: this._id,\n      data: data\n    };\n    let msg = KernelMessage.createShellMessage(\n      options,\n      content,\n      metadata,\n      buffers\n    );\n    return this._kernel.sendShellMessage(msg, false, true);\n  }\n\n  /**\n   * Close the comm.\n   *\n   * #### Notes\n   * This will send a `comm_close` message to the kernel, and call the\n   * `onClose` callback if set.\n   *\n   * This is a no-op if the comm is already closed.\n   *\n   * **See also:** [[ICommClose]], [[onClose]]\n   */\n  close(\n    data?: JSONValue,\n    metadata?: JSONObject,\n    buffers: (ArrayBuffer | ArrayBufferView)[] = []\n  ): Kernel.IFuture {\n    if (this.isDisposed || this._kernel.isDisposed) {\n      throw new Error('Cannot close');\n    }\n    let options: KernelMessage.IOptions = {\n      msgType: 'comm_msg',\n      channel: 'shell',\n      username: this._kernel.username,\n      session: this._kernel.clientId\n    };\n    let content: KernelMessage.ICommClose = {\n      comm_id: this._id,\n      data: data || {}\n    };\n    let msg = KernelMessage.createShellMessage(\n      options,\n      content,\n      metadata,\n      buffers\n    );\n    let future = this._kernel.sendShellMessage(msg, false, true);\n    options.channel = 'iopub';\n    let onClose = this._onClose;\n    if (onClose) {\n      let ioMsg = KernelMessage.createMessage(\n        options,\n        content,\n        metadata,\n        buffers\n      );\n      // In the future, we may want to communicate back to the user the possible\n      // promise returned from onClose.\n      onClose(ioMsg as KernelMessage.ICommCloseMsg);\n    }\n    this.dispose();\n    return future;\n  }\n\n  private _target = '';\n  private _id = '';\n  private _kernel: Kernel.IKernel;\n  private _onClose: (\n    msg: KernelMessage.ICommCloseMsg\n  ) => void | PromiseLike<void>;\n  private _onMsg: (msg: KernelMessage.ICommMsgMsg) => void | PromiseLike<void>;\n}\n"]}