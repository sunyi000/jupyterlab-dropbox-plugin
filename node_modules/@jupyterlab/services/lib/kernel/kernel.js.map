{"version":3,"file":"kernel.js","sourceRoot":"","sources":["../../../../../services/src/kernel/kernel.ts"],"names":[],"mappings":";AAAA,0CAA0C;AAC1C,2DAA2D;;AAY3D,uCAA0C;AAI1C;;GAEG;AACH,IAAiB,MAAM,CA0+BtB;AA1+BD,WAAiB,MAAM;IA6brB;;;;;;;;;;;;;;OAcG;IACH,kBACE,EAAU,EACV,QAAqC;QAErC,OAAO,uBAAa,CAAC,QAAQ,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;IAC9C,CAAC;IALe,eAAQ,WAKvB,CAAA;IAED;;;;;;;;;OASG;IACH,kBACE,QAAqC;QAErC,OAAO,uBAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAC1C,CAAC;IAJe,eAAQ,WAIvB,CAAA;IAED;;;;;;;;;;;OAWG;IACH,qBACE,QAAqC;QAErC,OAAO,uBAAa,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IAC7C,CAAC;IAJe,kBAAW,cAI1B,CAAA;IAED;;;;;;;;;;;;;;;OAeG;IACH,kBAAyB,UAA2B,EAAE;QACpD,OAAO,uBAAa,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IACzC,CAAC;IAFe,eAAQ,WAEvB,CAAA;IAED;;;;;;;;;;;;OAYG;IACH,mBACE,KAAoB,EACpB,QAAqC;QAErC,OAAO,uBAAa,CAAC,SAAS,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAClD,CAAC;IALe,gBAAS,YAKxB,CAAA;IAED;;;;;;;;OAQG;IACH,kBACE,EAAU,EACV,QAAqC;QAErC,OAAO,uBAAa,CAAC,QAAQ,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;IAC9C,CAAC;IALe,eAAQ,WAKvB,CAAA;IAED;;;;OAIG;IACH,qBACE,QAAqC;QAErC,OAAO,uBAAa,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IAC7C,CAAC;IAJe,kBAAW,cAI1B,CAAA;AAobH,CAAC,EA1+BgB,MAAM,GAAN,cAAM,KAAN,cAAM,QA0+BtB","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { IIterator } from '@phosphor/algorithm';\n\nimport { JSONObject, JSONValue } from '@phosphor/coreutils';\n\nimport { IDisposable } from '@phosphor/disposable';\n\nimport { ISignal } from '@phosphor/signaling';\n\nimport { ServerConnection } from '..';\n\nimport { DefaultKernel } from './default';\n\nimport { KernelMessage } from './messages';\n\n/**\n * A namespace for kernel types, interfaces, and type checker functions.\n */\nexport namespace Kernel {\n  /**\n   * Interface of a Kernel connection that is managed by a session.\n   *\n   * #### Notes\n   * The Kernel object is tied to the lifetime of the Kernel id, which is a\n   * unique id for the Kernel session on the server.  The Kernel object manages\n   * a websocket connection internally, and will auto-restart if the websocket\n   * temporarily loses connection.  Restarting creates a new Kernel process on\n   * the server, but preserves the Kernel id.\n   */\n  export interface IKernelConnection extends IDisposable {\n    /**\n     * The id of the server-side kernel.\n     */\n    readonly id: string;\n\n    /**\n     * The name of the server-side kernel.\n     */\n    readonly name: string;\n\n    /**\n     * The model associated with the kernel.\n     */\n    readonly model: Kernel.IModel;\n\n    /**\n     * The client username.\n     */\n    readonly username: string;\n\n    /**\n     * The client unique id.\n     *\n     * #### Notes\n     * This should be unique for a particular kernel connection object.\n     */\n    readonly clientId: string;\n\n    /**\n     * The current status of the kernel.\n     */\n    readonly status: Kernel.Status;\n\n    /**\n     * The cached kernel info.\n     *\n     * #### Notes\n     * This value will be null until the kernel is ready.\n     */\n    readonly info: KernelMessage.IInfoReply | null;\n\n    /**\n     * Test whether the kernel is ready.\n     *\n     * #### Notes\n     * A kernel is ready when the communication channel is active and we have\n     * cached the kernel info.\n     */\n    readonly isReady: boolean;\n\n    /**\n     * A promise that resolves when the kernel is initially ready after a start\n     * or restart.\n     *\n     * #### Notes\n     * A kernel is ready when the communication channel is active and we have\n     * cached the kernel info.\n     */\n    readonly ready: Promise<void>;\n\n    /**\n     * Get the kernel spec.\n     *\n     * @returns A promise that resolves with the kernel spec for this kernel.\n     */\n    getSpec(): Promise<Kernel.ISpecModel>;\n\n    /**\n     * Send a shell message to the kernel.\n     *\n     * @param msg - The fully-formed shell message to send.\n     *\n     * @param expectReply - Whether to expect a shell reply message.\n     *\n     * @param disposeOnDone - Whether to dispose of the future when done.\n     *\n     * #### Notes\n     * Send a message to the kernel's shell channel, yielding a future object\n     * for accepting replies.\n     *\n     * If `expectReply` is given and `true`, the future is done when both a\n     * shell reply and an idle status message are received with the appropriate\n     * parent header, in which case the `.done` promise resolves to the reply.\n     * If `expectReply` is not given or is `false`, the future is done when an\n     * idle status message with the appropriate parent header is received, in\n     * which case the `.done` promise resolves to `undefined`.\n     *\n     * If `disposeOnDone` is given and `false`, the future will not be disposed\n     * of when the future is done, instead relying on the caller to dispose of\n     * it. This allows for the handling of out-of-order output from ill-behaved\n     * kernels.\n     *\n     * All replies are validated as valid kernel messages.\n     *\n     * If the kernel status is `'dead'`, this will throw an error.\n     */\n    sendShellMessage(\n      msg: KernelMessage.IShellMessage,\n      expectReply?: boolean,\n      disposeOnDone?: boolean\n    ): Kernel.IFuture;\n\n    /**\n     * Reconnect to a disconnected kernel.\n     *\n     * @returns A promise that resolves when the kernel has reconnected.\n     *\n     * #### Notes\n     * This just refreshes the connection to an existing kernel, and does not\n     * perform an HTTP request to the server or restart the kernel.\n     */\n    reconnect(): Promise<void>;\n\n    /**\n     * Interrupt a kernel.\n     *\n     * @returns A promise that resolves when the kernel has interrupted.\n     *\n     * #### Notes\n     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels).\n     *\n     * The promise is fulfilled on a valid response and rejected otherwise.\n     *\n     * It is assumed that the API call does not mutate the kernel id or name.\n     *\n     * The promise will be rejected if the kernel status is `'dead'` or if the\n     * request fails or the response is invalid.\n     */\n    interrupt(): Promise<void>;\n\n    /**\n     * Restart a kernel.\n     *\n     * @returns A promise that resolves when the kernel has restarted.\n     *\n     * #### Notes\n     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels) and validates the response model.\n     *\n     * Any existing Future or Comm objects are cleared.\n     *\n     * It is assumed that the API call does not mutate the kernel id or name.\n     *\n     * The promise will be rejected if the kernel status is `'dead'` or if the\n     * request fails or the response is invalid.\n     */\n    restart(): Promise<void>;\n\n    /**\n     * Send a `kernel_info_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#kernel-info).\n     *\n     * Fulfills with the `kernel_info_response` content when the shell reply is\n     * received and validated.\n     */\n    requestKernelInfo(): Promise<KernelMessage.IInfoReplyMsg>;\n\n    /**\n     * Send a `complete_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#completion).\n     *\n     * Fulfills with the `complete_reply` content when the shell reply is\n     * received and validated.\n     */\n    requestComplete(\n      content: KernelMessage.ICompleteRequest\n    ): Promise<KernelMessage.ICompleteReplyMsg>;\n\n    /**\n     * Send an `inspect_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#introspection).\n     *\n     * Fulfills with the `inspect_reply` content when the shell reply is\n     * received and validated.\n     */\n    requestInspect(\n      content: KernelMessage.IInspectRequest\n    ): Promise<KernelMessage.IInspectReplyMsg>;\n\n    /**\n     * Send a `history_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#history).\n     *\n     * Fulfills with the `history_reply` content when the shell reply is\n     * received and validated.\n     */\n    requestHistory(\n      content: KernelMessage.IHistoryRequest\n    ): Promise<KernelMessage.IHistoryReplyMsg>;\n\n    /**\n     * Send an `execute_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @param disposeOnDone - Whether to dispose of the future when done.\n     *\n     * @returns A kernel future.\n     *\n     * #### Notes\n     * See [Messaging in\n     * Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#execute).\n     *\n     * This method returns a kernel future, rather than a promise, since execution may\n     * have many response messages (for example, many iopub display messages).\n     *\n     * Future `onReply` is called with the `execute_reply` content when the\n     * shell reply is received and validated.\n     *\n     * **See also:** [[IExecuteReply]]\n     */\n    requestExecute(\n      content: KernelMessage.IExecuteRequest,\n      disposeOnDone?: boolean,\n      metadata?: JSONObject\n    ): Kernel.IFuture;\n\n    /**\n     * Send an `is_complete_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#code-completeness).\n     *\n     * Fulfills with the `is_complete_response` content when the shell reply is\n     * received and validated.\n     */\n    requestIsComplete(\n      content: KernelMessage.IIsCompleteRequest\n    ): Promise<KernelMessage.IIsCompleteReplyMsg>;\n\n    /**\n     * Send a `comm_info_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#comm_info).\n     *\n     * Fulfills with the `comm_info_reply` content when the shell reply is\n     * received and validated.\n     */\n    requestCommInfo(\n      content: KernelMessage.ICommInfoRequest\n    ): Promise<KernelMessage.ICommInfoReplyMsg>;\n\n    /**\n     * Send an `input_reply` message.\n     *\n     * @param content - The content of the reply.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#messages-on-the-stdin-router-dealer-sockets).\n     */\n    sendInputReply(content: KernelMessage.IInputReply): void;\n\n    /**\n     * Connect to a comm, or create a new one.\n     *\n     * @param targetName - The name of the comm target.\n     *\n     * @param id - The comm id.\n     *\n     * @returns A comm instance.\n     */\n    connectToComm(targetName: string, commId?: string): Kernel.IComm;\n\n    /**\n     * Register a comm target handler.\n     *\n     * @param targetName - The name of the comm target.\n     *\n     * @param callback - The callback invoked for a comm open message.\n     *\n     * #### Notes\n     * Only one comm target can be registered to a target name at a time, an\n     * existing callback for the same target name will be overridden.  A registered\n     * comm target handler will take precedence over a comm which specifies a\n     * `target_module`.\n     *\n     * If the callback returns a promise, kernel message processing will pause\n     * until the returned promise is fulfilled.\n     */\n    registerCommTarget(\n      targetName: string,\n      callback: (\n        comm: Kernel.IComm,\n        msg: KernelMessage.ICommOpenMsg\n      ) => void | PromiseLike<void>\n    ): void;\n\n    /**\n     * Remove a comm target handler.\n     *\n     * @param targetName - The name of the comm target to remove.\n     *\n     * @param callback - The callback to remove.\n     *\n     * #### Notes\n     * The comm target is only removed if it matches the callback argument.\n     */\n    removeCommTarget(\n      targetName: string,\n      callback: (\n        comm: Kernel.IComm,\n        msg: KernelMessage.ICommOpenMsg\n      ) => void | PromiseLike<void>\n    ): void;\n\n    /**\n     * Register an IOPub message hook.\n     *\n     * @param msg_id - The parent_header message id in messages the hook should\n     * intercept.\n     *\n     * @param hook - The callback invoked for the message.\n     *\n     * #### Notes\n     * The IOPub hook system allows you to preempt the handlers for IOPub\n     * messages with a given parent_header message id. The most recently\n     * registered hook is run first. If a hook return value resolves to false,\n     * any later hooks and the future's onIOPub handler will not run. If a hook\n     * throws an error, the error is logged to the console and the next hook is\n     * run. If a hook is registered during the hook processing, it will not run\n     * until the next message. If a hook is disposed during the hook processing,\n     * it will be deactivated immediately.\n     *\n     * See also [[IFuture.registerMessageHook]].\n     */\n    registerMessageHook(\n      msgId: string,\n      hook: (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>\n    ): void;\n\n    /**\n     * Remove an IOPub message hook.\n     *\n     * @param msg_id - The parent_header message id the hook intercepted.\n     *\n     * @param hook - The callback invoked for the message.\n     *\n     */\n    removeMessageHook(\n      msgId: string,\n      hook: (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>\n    ): void;\n  }\n\n  /**\n   * The full interface of a kernel.\n   */\n  export interface IKernel extends IKernelConnection {\n    /**\n     * A signal emitted when the kernel is shut down.\n     */\n    terminated: ISignal<this, void>;\n\n    /**\n     * A signal emitted when the kernel status changes.\n     */\n    statusChanged: ISignal<this, Kernel.Status>;\n\n    /**\n     * A signal emitted after an iopub kernel message is handled.\n     */\n    iopubMessage: ISignal<this, KernelMessage.IIOPubMessage>;\n\n    /**\n     * A signal emitted for unhandled non-iopub kernel messages that claimed to\n     * be responses for messages we sent using this kernel object.\n     */\n    unhandledMessage: ISignal<this, KernelMessage.IMessage>;\n\n    /**\n     * A signal emitted when any kernel message is sent or received.\n     *\n     * #### Notes\n     * This signal is emitted before any message handling has happened. The\n     * message should be treated as read-only.\n     */\n    anyMessage: ISignal<this, IAnyMessageArgs>;\n\n    /**\n     * The server settings for the kernel.\n     */\n    readonly serverSettings: ServerConnection.ISettings;\n\n    /**\n     * Shutdown a kernel.\n     *\n     * @returns A promise that resolves when the kernel has shut down.\n     *\n     * #### Notes\n     * Uses the [Jupyter Notebook\n     * API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels).\n     *\n     * On a valid response, closes the websocket, emits the [[terminated]]\n     * signal, disposes of the kernel object, and fulfills the promise.\n     *\n     * The promise will be rejected if the kernel status is `'dead'`, the\n     * request fails, or the response is invalid.\n     */\n    shutdown(): Promise<void>;\n  }\n\n  /**\n   * Find a kernel by id.\n   *\n   * @param id - The id of the kernel of interest.\n   *\n   * @param settings - The optional server settings.\n   *\n   * @returns A promise that resolves with the model for the kernel.\n   *\n   * #### Notes\n   * If the kernel was already started via `startNewKernel`, we return its\n   * `Kernel.IModel`. Otherwise, we attempt to find the existing kernel. The\n   * promise is fulfilled when the kernel is found, otherwise the promise is\n   * rejected.\n   */\n  export function findById(\n    id: string,\n    settings?: ServerConnection.ISettings\n  ): Promise<IModel> {\n    return DefaultKernel.findById(id, settings);\n  }\n\n  /**\n   * Fetch all of the kernel specs.\n   *\n   * @param settings - The optional server settings.\n   *\n   * @returns A promise that resolves with the kernel specs.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernelspecs).\n   */\n  export function getSpecs(\n    settings?: ServerConnection.ISettings\n  ): Promise<Kernel.ISpecModels> {\n    return DefaultKernel.getSpecs(settings);\n  }\n\n  /**\n   * Fetch the running kernels.\n   *\n   * @param settings - The optional server settings.\n   *\n   * @returns A promise that resolves with the list of running kernels.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels) and validates the response model.\n   *\n   * The promise is fulfilled on a valid response and rejected otherwise.\n   */\n  export function listRunning(\n    settings?: ServerConnection.ISettings\n  ): Promise<Kernel.IModel[]> {\n    return DefaultKernel.listRunning(settings);\n  }\n\n  /**\n   * Start a new kernel.\n   *\n   * @param options - The options used to create the kernel.\n   *\n   * @returns A promise that resolves with a kernel object.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels) and validates the response model.\n   *\n   * If no options are given or the kernel name is not given, the\n   * default kernel will by started by the server.\n   *\n   * Wraps the result in a Kernel object. The promise is fulfilled\n   * when the kernel is started by the server, otherwise the promise is rejected.\n   */\n  export function startNew(options: Kernel.IOptions = {}): Promise<IKernel> {\n    return DefaultKernel.startNew(options);\n  }\n\n  /**\n   * Connect to a running kernel.\n   *\n   * @param model - The model of the running kernel.\n   *\n   * @param settings - The server settings for the request.\n   *\n   * @returns The kernel object.\n   *\n   * #### Notes\n   * If the kernel was already started via `startNewKernel`, the existing\n   * Kernel object info is used to create another instance.\n   */\n  export function connectTo(\n    model: Kernel.IModel,\n    settings?: ServerConnection.ISettings\n  ): IKernel {\n    return DefaultKernel.connectTo(model, settings);\n  }\n\n  /**\n   * Shut down a kernel by id.\n   *\n   * @param id - The id of the running kernel.\n   *\n   * @param settings - The server settings for the request.\n   *\n   * @returns A promise that resolves when the kernel is shut down.\n   */\n  export function shutdown(\n    id: string,\n    settings?: ServerConnection.ISettings\n  ): Promise<void> {\n    return DefaultKernel.shutdown(id, settings);\n  }\n\n  /**\n   * Shut down all kernels.\n   *\n   * @returns A promise that resolves when all of the kernels are shut down.\n   */\n  export function shutdownAll(\n    settings?: ServerConnection.ISettings\n  ): Promise<void> {\n    return DefaultKernel.shutdownAll(settings);\n  }\n\n  /**\n   * The options object used to initialize a kernel.\n   */\n  export interface IOptions {\n    /**\n     * The kernel type (e.g. python3).\n     */\n    name?: string;\n\n    /**\n     * The server settings for the kernel.\n     */\n    serverSettings?: ServerConnection.ISettings;\n\n    /**\n     * The username of the kernel client.\n     */\n    username?: string;\n\n    /**\n     * The unique identifier for the kernel client.\n     */\n    clientId?: string;\n  }\n\n  /**\n   * Object which manages kernel instances for a given base url.\n   *\n   * #### Notes\n   * The manager is responsible for maintaining the state of running\n   * kernels and the initial fetch of kernel specs.\n   */\n  export interface IManager extends IDisposable {\n    /**\n     * A signal emitted when the kernel specs change.\n     */\n    specsChanged: ISignal<IManager, ISpecModels>;\n\n    /**\n     * A signal emitted when the running kernels change.\n     */\n    runningChanged: ISignal<IManager, IModel[]>;\n\n    /**\n     * The server settings for the manager.\n     */\n    serverSettings?: ServerConnection.ISettings;\n\n    /**\n     * The kernel spec models.\n     *\n     * #### Notes\n     * The value will be null until the manager is ready.\n     */\n    readonly specs: Kernel.ISpecModels | null;\n\n    /**\n     * Whether the manager is ready.\n     */\n    readonly isReady: boolean;\n\n    /**\n     * A promise that resolves when the manager is initially ready.\n     */\n    readonly ready: Promise<void>;\n\n    /**\n     * Create an iterator over the known running kernels.\n     *\n     * @returns A new iterator over the running kernels.\n     */\n    running(): IIterator<IModel>;\n\n    /**\n     * Force a refresh of the specs from the server.\n     *\n     * @returns A promise that resolves when the specs are fetched.\n     *\n     * #### Notes\n     * This is intended to be called only in response to a user action,\n     * since the manager maintains its internal state.\n     */\n    refreshSpecs(): Promise<void>;\n\n    /**\n     * Force a refresh of the running kernels.\n     *\n     * @returns A promise that resolves when the models are refreshed.\n     *\n     * #### Notes\n     * This is intended to be called only in response to a user action,\n     * since the manager maintains its internal state.\n     */\n    refreshRunning(): Promise<void>;\n\n    /**\n     * Start a new kernel.\n     *\n     * @param options - The kernel options to use.\n     *\n     * @returns A promise that resolves with the kernel instance.\n     *\n     * #### Notes\n     * The manager `serverSettings` will be always be used.\n     */\n    startNew(options?: IOptions): Promise<IKernel>;\n\n    /**\n     * Find a kernel by id.\n     *\n     * @param id - The id of the target kernel.\n     *\n     * @returns A promise that resolves with the kernel's model.\n     */\n    findById(id: string): Promise<IModel>;\n\n    /**\n     * Connect to an existing kernel.\n     *\n     * @param model - The model of the target kernel.\n     *\n     * @returns A promise that resolves with the new kernel instance.\n     */\n    connectTo(model: Kernel.IModel): IKernel;\n\n    /**\n     * Shut down a kernel by id.\n     *\n     * @param id - The id of the target kernel.\n     *\n     * @returns A promise that resolves when the operation is complete.\n     */\n    shutdown(id: string): Promise<void>;\n\n    /**\n     * Shut down all kernels.\n     *\n     * @returns A promise that resolves when all of the kernels are shut down.\n     */\n    shutdownAll(): Promise<void>;\n  }\n\n  /**\n   * A Future interface for responses from the kernel.\n   *\n   * When a message is sent to a kernel, a Future is created to handle any\n   * responses that may come from the kernel.\n   */\n  export interface IFuture extends IDisposable {\n    /**\n     * The original outgoing message.\n     */\n    readonly msg: KernelMessage.IShellMessage;\n\n    /**\n     * A promise that resolves when the future is done.\n     *\n     * #### Notes\n     * The future is done when there are no more responses expected from the\n     * kernel.\n     *\n     * The `done` promise resolves to the reply message if there is one,\n     * otherwise it resolves to `undefined`.\n     */\n    readonly done: Promise<KernelMessage.IShellMessage | undefined>;\n\n    /**\n     * The reply handler for the kernel future.\n     *\n     * #### Notes\n     * If the handler returns a promise, all kernel message processing pauses\n     * until the promise is resolved. If there is a reply message, the future\n     * `done` promise also resolves to the reply message after this handler has\n     * been called.\n     */\n    onReply: (msg: KernelMessage.IShellMessage) => void | PromiseLike<void>;\n\n    /**\n     * The stdin handler for the kernel future.\n     *\n     * #### Notes\n     * If the handler returns a promise, all kernel message processing pauses\n     * until the promise is resolved.\n     */\n    onStdin: (msg: KernelMessage.IStdinMessage) => void | PromiseLike<void>;\n\n    /**\n     * The iopub handler for the kernel future.\n     *\n     * #### Notes\n     * If the handler returns a promise, all kernel message processing pauses\n     * until the promise is resolved.\n     */\n    onIOPub: (msg: KernelMessage.IIOPubMessage) => void | PromiseLike<void>;\n\n    /**\n     * Register hook for IOPub messages.\n     *\n     * @param hook - The callback invoked for an IOPub message.\n     *\n     * #### Notes\n     * The IOPub hook system allows you to preempt the handlers for IOPub\n     * messages handled by the future.\n     *\n     * The most recently registered hook is run first. A hook can return a\n     * boolean or a promise to a boolean, in which case all kernel message\n     * processing pauses until the promise is fulfilled. If a hook return value\n     * resolves to false, any later hooks will not run and the function will\n     * return a promise resolving to false. If a hook throws an error, the error\n     * is logged to the console and the next hook is run. If a hook is\n     * registered during the hook processing, it will not run until the next\n     * message. If a hook is removed during the hook processing, it will be\n     * deactivated immediately.\n     */\n    registerMessageHook(\n      hook: (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>\n    ): void;\n\n    /**\n     * Remove a hook for IOPub messages.\n     *\n     * @param hook - The hook to remove.\n     *\n     * #### Notes\n     * If a hook is removed during the hook processing, it will be deactivated immediately.\n     */\n    removeMessageHook(\n      hook: (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>\n    ): void;\n\n    /**\n     * Send an `input_reply` message.\n     */\n    sendInputReply(content: KernelMessage.IInputReply): void;\n  }\n\n  /**\n   * A client side Comm interface.\n   */\n  export interface IComm extends IDisposable {\n    /**\n     * The unique id for the comm channel.\n     */\n    readonly commId: string;\n\n    /**\n     * The target name for the comm channel.\n     */\n    readonly targetName: string;\n\n    /**\n     * Callback for a comm close event.\n     *\n     * #### Notes\n     * This is called when the comm is closed from either the server or client.\n     * If this is called in response to a kernel message and the handler returns\n     * a promise, all kernel message processing pauses until the promise is\n     * resolved.\n     */\n    onClose: (msg: KernelMessage.ICommCloseMsg) => void | PromiseLike<void>;\n\n    /**\n     * Callback for a comm message received event.\n     *\n     * #### Notes\n     * If the handler returns a promise, all kernel message processing pauses\n     * until the promise is resolved.\n     */\n    onMsg: (msg: KernelMessage.ICommMsgMsg) => void | PromiseLike<void>;\n\n    /**\n     * Open a comm with optional data and metadata.\n     *\n     * @param data - The data to send to the server on opening.\n     *\n     * @param metadata - Additional metatada for the message.\n     *\n     * @returns A future for the generated message.\n     *\n     * #### Notes\n     * This sends a `comm_open` message to the server.\n     */\n    open(\n      data?: JSONValue,\n      metadata?: JSONObject,\n      buffers?: (ArrayBuffer | ArrayBufferView)[]\n    ): IFuture;\n\n    /**\n     * Send a `comm_msg` message to the kernel.\n     *\n     * @param data - The data to send to the server on opening.\n     *\n     * @param metadata - Additional metatada for the message.\n     *\n     * @param buffers - Optional buffer data.\n     *\n     * @param disposeOnDone - Whether to dispose of the future when done.\n     *\n     * @returns A future for the generated message.\n     *\n     * #### Notes\n     * This is a no-op if the comm has been closed.\n     */\n    send(\n      data: JSONValue,\n      metadata?: JSONObject,\n      buffers?: (ArrayBuffer | ArrayBufferView)[],\n      disposeOnDone?: boolean\n    ): IFuture;\n\n    /**\n     * Close the comm.\n     *\n     * @param data - The data to send to the server on opening.\n     *\n     * @param metadata - Additional metatada for the message.\n     *\n     * @returns A future for the generated message.\n     *\n     * #### Notes\n     * This will send a `comm_close` message to the kernel, and call the\n     * `onClose` callback if set.\n     *\n     * This is a no-op if the comm is already closed.\n     */\n    close(\n      data?: JSONValue,\n      metadata?: JSONObject,\n      buffers?: (ArrayBuffer | ArrayBufferView)[]\n    ): IFuture;\n  }\n\n  /**\n   * The valid Kernel status states.\n   */\n  export type Status =\n    | 'unknown'\n    | 'starting'\n    | 'reconnecting'\n    | 'idle'\n    | 'busy'\n    | 'restarting'\n    | 'dead'\n    | 'connected';\n\n  /**\n   * The kernel model provided by the server.\n   *\n   * #### Notes\n   * See the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels).\n   */\n  export interface IModel extends JSONObject {\n    /**\n     * Unique identifier of the kernel server session.\n     */\n    readonly id: string;\n\n    /**\n     * The name of the kernel.\n     */\n    readonly name: string;\n  }\n\n  /**\n   * Kernel Spec interface.\n   *\n   * #### Notes\n   * See [Kernel specs](https://jupyter-client.readthedocs.io/en/latest/kernels.html#kernelspecs).\n   */\n  export interface ISpecModel extends JSONObject {\n    /**\n     * The name of the kernel spec.\n     */\n    readonly name: string;\n\n    /**\n     * The name of the language of the kernel.\n     */\n    readonly language: string;\n\n    /**\n     * A list of command line arguments used to start the kernel.\n     */\n    readonly argv: string[];\n\n    /**\n     * The kernel’s name as it should be displayed in the UI.\n     */\n    readonly display_name: string;\n\n    /**\n     * A dictionary of environment variables to set for the kernel.\n     */\n    readonly env?: JSONObject;\n\n    /**\n     * A mapping of resource file name to download path.\n     */\n    readonly resources: { [key: string]: string };\n  }\n\n  /**\n   * The available kernelSpec models.\n   *\n   * #### Notes\n   * See the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernelspecs).\n   */\n  export interface ISpecModels extends JSONObject {\n    /**\n     * The name of the default kernel spec.\n     */\n    default: string;\n\n    /**\n     * A mapping of kernel spec name to spec.\n     */\n    readonly kernelspecs: { [key: string]: ISpecModel };\n  }\n\n  /**\n   * Arguments interface for the anyMessage signal.\n   */\n  export interface IAnyMessageArgs {\n    /**\n     * The message that is being signaled.\n     */\n    msg: Readonly<KernelMessage.IMessage>;\n\n    /**\n     * The direction of the message.\n     */\n    direction: 'send' | 'recv';\n  }\n}\n"]}