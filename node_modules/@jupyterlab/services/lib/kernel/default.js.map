{"version":3,"file":"default.js","sourceRoot":"","sources":["../../../../../services/src/kernel/default.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { URLExt } from '@jupyterlab/coreutils';\n\nimport { UUID } from '@phosphor/coreutils';\n\nimport { ArrayExt, each, find } from '@phosphor/algorithm';\n\nimport { JSONExt, JSONObject, PromiseDelegate } from '@phosphor/coreutils';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { ServerConnection } from '..';\n\nimport { CommHandler } from './comm';\n\nimport { Kernel } from './kernel';\n\nimport { KernelMessage } from './messages';\n\nimport { KernelFutureHandler } from './future';\n\nimport * as serialize from './serialize';\n\nimport * as validate from './validate';\n\n/**\n * The url for the kernel service.\n */\nconst KERNEL_SERVICE_URL = 'api/kernels';\n\n/**\n * The url for the kernelspec service.\n */\nconst KERNELSPEC_SERVICE_URL = 'api/kernelspecs';\n\n// Stub for requirejs.\ndeclare var requirejs: any;\n\n/**\n * Implementation of the Kernel object.\n *\n * #### Notes\n * Messages from the server are handled in the order they were received and\n * asynchronously. Any message handler can return a promise, and message\n * handling will pause until the promise is fulfilled.\n */\nexport class DefaultKernel implements Kernel.IKernel {\n  /**\n   * Construct a kernel object.\n   */\n  constructor(options: Kernel.IOptions, id: string) {\n    this._name = options.name;\n    this._id = id;\n    this.serverSettings =\n      options.serverSettings || ServerConnection.makeSettings();\n    this._clientId = options.clientId || UUID.uuid4();\n    this._username = options.username || '';\n    this._futures = new Map<string, KernelFutureHandler>();\n    this._comms = new Map<string, Kernel.IComm>();\n    this._createSocket();\n    Private.runningKernels.push(this);\n  }\n\n  /**\n   * A signal emitted when the kernel is shut down.\n   */\n  get terminated(): ISignal<this, void> {\n    return this._terminated;\n  }\n\n  /**\n   * The server settings for the kernel.\n   */\n  readonly serverSettings: ServerConnection.ISettings;\n\n  /**\n   * A signal emitted when the kernel status changes.\n   */\n  get statusChanged(): ISignal<this, Kernel.Status> {\n    return this._statusChanged;\n  }\n\n  /**\n   * A signal emitted for iopub kernel messages.\n   *\n   * #### Notes\n   * This signal is emitted after the iopub message is handled asynchronously.\n   */\n  get iopubMessage(): ISignal<this, KernelMessage.IIOPubMessage> {\n    return this._iopubMessage;\n  }\n\n  /**\n   * A signal emitted for unhandled kernel message.\n   *\n   * #### Notes\n   * This signal is emitted for a message that was not handled. It is emitted\n   * during the asynchronous message handling code.\n   */\n  get unhandledMessage(): ISignal<this, KernelMessage.IMessage> {\n    return this._unhandledMessage;\n  }\n\n  /**\n   * A signal emitted for any kernel message.\n   *\n   * #### Notes\n   * This signal is emitted when a message is received, before it is handled\n   * asynchronously.\n   *\n   * The behavior is undefined if the message is modified during message\n   * handling. As such, the message should be treated as read-only.\n   */\n  get anyMessage(): ISignal<this, Kernel.IAnyMessageArgs> {\n    return this._anyMessage;\n  }\n\n  /**\n   * The id of the server-side kernel.\n   */\n  get id(): string {\n    return this._id;\n  }\n\n  /**\n   * The name of the server-side kernel.\n   */\n  get name(): string {\n    return this._name;\n  }\n\n  /**\n   * Get the model associated with the kernel.\n   */\n  get model(): Kernel.IModel {\n    return { name: this.name, id: this.id };\n  }\n\n  /**\n   * The client username.\n   */\n  get username(): string {\n    return this._username;\n  }\n\n  /**\n   * The client unique id.\n   */\n  get clientId(): string {\n    return this._clientId;\n  }\n\n  /**\n   * The current status of the kernel.\n   */\n  get status(): Kernel.Status {\n    return this._status;\n  }\n\n  /**\n   * Test whether the kernel has been disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * The cached kernel info.\n   *\n   * #### Notes\n   * This value will be null until the kernel is ready.\n   */\n  get info(): KernelMessage.IInfoReply | null {\n    return this._info;\n  }\n\n  /**\n   * Test whether the kernel is ready.\n   */\n  get isReady(): boolean {\n    return this._isReady;\n  }\n\n  /**\n   * A promise that is fulfilled when the kernel is ready.\n   */\n  get ready(): Promise<void> {\n    return this._connectionPromise.promise;\n  }\n\n  /**\n   * Get the kernel spec.\n   *\n   * @returns A promise that resolves with the kernel spec.\n   */\n  getSpec(): Promise<Kernel.ISpecModel> {\n    if (this._specPromise) {\n      return this._specPromise;\n    }\n    this._specPromise = Private.findSpecs(this.serverSettings).then(specs => {\n      return specs.kernelspecs[this._name];\n    });\n    return this._specPromise;\n  }\n\n  /**\n   * Clone the current kernel with a new clientId.\n   */\n  clone(): Kernel.IKernel {\n    return new DefaultKernel(\n      {\n        name: this._name,\n        username: this._username,\n        serverSettings: this.serverSettings\n      },\n      this._id\n    );\n  }\n\n  /**\n   * Dispose of the resources held by the kernel.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    this._terminated.emit(void 0);\n    this._status = 'dead';\n    this._clearSocket();\n    this._futures.forEach(future => {\n      future.dispose();\n    });\n    this._comms.forEach(comm => {\n      comm.dispose();\n    });\n    this._kernelSession = '';\n    this._msgChain = null;\n    this._displayIdToParentIds.clear();\n    this._msgIdToDisplayIds.clear();\n    ArrayExt.removeFirstOf(Private.runningKernels, this);\n    Signal.clearData(this);\n  }\n\n  /**\n   * Send a shell message to the kernel.\n   *\n   * #### Notes\n   * Send a message to the kernel's shell channel, yielding a future object\n   * for accepting replies.\n   *\n   * If `expectReply` is given and `true`, the future is disposed when both a\n   * shell reply and an idle status message are received. If `expectReply`\n   * is not given or is `false`, the future is resolved when an idle status\n   * message is received.\n   * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.\n   * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.\n   *\n   * All replies are validated as valid kernel messages.\n   *\n   * If the kernel status is `dead`, this will throw an error.\n   */\n  sendShellMessage(\n    msg: KernelMessage.IShellMessage,\n    expectReply = false,\n    disposeOnDone = true\n  ): Kernel.IFuture {\n    if (this.status === 'dead') {\n      throw new Error('Kernel is dead');\n    }\n    if (!this._isReady || !this._ws) {\n      this._pendingMessages.push(msg);\n    } else {\n      this._ws.send(serialize.serialize(msg));\n    }\n    this._anyMessage.emit({ msg, direction: 'send' });\n    let future = new KernelFutureHandler(\n      () => {\n        let msgId = msg.header.msg_id;\n        this._futures.delete(msgId);\n        // Remove stored display id information.\n        let displayIds = this._msgIdToDisplayIds.get(msgId);\n        if (!displayIds) {\n          return;\n        }\n        displayIds.forEach(displayId => {\n          let msgIds = this._displayIdToParentIds.get(displayId);\n          if (msgIds) {\n            let idx = msgIds.indexOf(msgId);\n            if (idx === -1) {\n              return;\n            }\n            if (msgIds.length === 1) {\n              this._displayIdToParentIds.delete(displayId);\n            } else {\n              msgIds.splice(idx, 1);\n              this._displayIdToParentIds.set(displayId, msgIds);\n            }\n          }\n        });\n        this._msgIdToDisplayIds.delete(msgId);\n      },\n      msg,\n      expectReply,\n      disposeOnDone,\n      this\n    );\n    this._futures.set(msg.header.msg_id, future);\n    return future;\n  }\n\n  /**\n   * Interrupt a kernel.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels).\n   *\n   * The promise is fulfilled on a valid response and rejected otherwise.\n   *\n   * It is assumed that the API call does not mutate the kernel id or name.\n   *\n   * The promise will be rejected if the kernel status is `Dead` or if the\n   * request fails or the response is invalid.\n   */\n  interrupt(): Promise<void> {\n    return Private.interruptKernel(this, this.serverSettings);\n  }\n\n  /**\n   * Restart a kernel.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels) and validates the response model.\n   *\n   * Any existing Future or Comm objects are cleared.\n   *\n   * The promise is fulfilled on a valid response and rejected otherwise.\n   *\n   * It is assumed that the API call does not mutate the kernel id or name.\n   *\n   * The promise will be rejected if the request fails or the response is\n   * invalid.\n   */\n  restart(): Promise<void> {\n    return Private.restartKernel(this, this.serverSettings);\n  }\n\n  /**\n   * Handle a restart on the kernel.  This is not part of the `IKernel`\n   * interface.\n   */\n  handleRestart(): void {\n    this._clearState();\n    this._updateStatus('restarting');\n    this._clearSocket();\n  }\n\n  /**\n   * Reconnect to a disconnected kernel.\n   *\n   * #### Notes\n   * Used when the websocket connection to the kernel is lost.\n   */\n  reconnect(): Promise<void> {\n    this._clearSocket();\n    this._updateStatus('reconnecting');\n    this._createSocket();\n    return this._connectionPromise.promise;\n  }\n\n  /**\n   * Shutdown a kernel.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels).\n   *\n   * The promise is fulfilled on a valid response and rejected otherwise.\n   *\n   * On a valid response, closes the websocket and disposes of the kernel\n   * object, and fulfills the promise.\n   *\n   * The promise will be rejected if the kernel status is `Dead` or if the\n   * request fails or the response is invalid.\n   */\n  shutdown(): Promise<void> {\n    if (this.status === 'dead') {\n      return Promise.reject(new Error('Kernel is dead'));\n    }\n    return Private.shutdownKernel(this.id, this.serverSettings).then(() => {\n      this._clearState();\n      this._clearSocket();\n    });\n  }\n\n  /**\n   * Send a `kernel_info_request` message.\n   *\n   * #### Notes\n   * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#kernel-info).\n   *\n   * Fulfills with the `kernel_info_response` content when the shell reply is\n   * received and validated.\n   *\n   * TODO: this should be automatically run every time our kernel restarts,\n   * before we say the kernel is ready, and cache the info and the kernel\n   * session id. Further calls to this should returned the cached results.\n   */\n  async requestKernelInfo(): Promise<KernelMessage.IInfoReplyMsg> {\n    let options: KernelMessage.IOptions = {\n      msgType: 'kernel_info_request',\n      channel: 'shell',\n      username: this._username,\n      session: this._clientId\n    };\n    let msg = KernelMessage.createShellMessage(options);\n    let reply = (await Private.handleShellMessage(\n      this,\n      msg\n    )) as KernelMessage.IInfoReplyMsg;\n    if (this.isDisposed) {\n      throw new Error('Disposed kernel');\n    }\n    this._info = reply.content;\n    return reply;\n  }\n\n  /**\n   * Send a `complete_request` message.\n   *\n   * #### Notes\n   * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#completion).\n   *\n   * Fulfills with the `complete_reply` content when the shell reply is\n   * received and validated.\n   */\n  requestComplete(\n    content: KernelMessage.ICompleteRequest\n  ): Promise<KernelMessage.ICompleteReplyMsg> {\n    let options: KernelMessage.IOptions = {\n      msgType: 'complete_request',\n      channel: 'shell',\n      username: this._username,\n      session: this._clientId\n    };\n    let msg = KernelMessage.createShellMessage(options, content);\n    return Private.handleShellMessage(this, msg) as Promise<\n      KernelMessage.ICompleteReplyMsg\n    >;\n  }\n\n  /**\n   * Send an `inspect_request` message.\n   *\n   * #### Notes\n   * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#introspection).\n   *\n   * Fulfills with the `inspect_reply` content when the shell reply is\n   * received and validated.\n   */\n  requestInspect(\n    content: KernelMessage.IInspectRequest\n  ): Promise<KernelMessage.IInspectReplyMsg> {\n    let options: KernelMessage.IOptions = {\n      msgType: 'inspect_request',\n      channel: 'shell',\n      username: this._username,\n      session: this._clientId\n    };\n    let msg = KernelMessage.createShellMessage(options, content);\n    return Private.handleShellMessage(this, msg) as Promise<\n      KernelMessage.IInspectReplyMsg\n    >;\n  }\n\n  /**\n   * Send a `history_request` message.\n   *\n   * #### Notes\n   * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#history).\n   *\n   * Fulfills with the `history_reply` content when the shell reply is\n   * received and validated.\n   */\n  requestHistory(\n    content: KernelMessage.IHistoryRequest\n  ): Promise<KernelMessage.IHistoryReplyMsg> {\n    let options: KernelMessage.IOptions = {\n      msgType: 'history_request',\n      channel: 'shell',\n      username: this._username,\n      session: this._clientId\n    };\n    let msg = KernelMessage.createShellMessage(options, content);\n    return Private.handleShellMessage(this, msg) as Promise<\n      KernelMessage.IHistoryReplyMsg\n    >;\n  }\n\n  /**\n   * Send an `execute_request` message.\n   *\n   * #### Notes\n   * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#execute).\n   *\n   * Future `onReply` is called with the `execute_reply` content when the\n   * shell reply is received and validated. The future will resolve when\n   * this message is received and the `idle` iopub status is received.\n   * The future will also be disposed at this point unless `disposeOnDone`\n   * is specified and `false`, in which case it is up to the caller to dispose\n   * of the future.\n   *\n   * **See also:** [[IExecuteReply]]\n   */\n  requestExecute(\n    content: KernelMessage.IExecuteRequest,\n    disposeOnDone: boolean = true,\n    metadata?: JSONObject\n  ): Kernel.IFuture {\n    let options: KernelMessage.IOptions = {\n      msgType: 'execute_request',\n      channel: 'shell',\n      username: this._username,\n      session: this._clientId\n    };\n    let defaults: JSONObject = {\n      silent: false,\n      store_history: true,\n      user_expressions: {},\n      allow_stdin: true,\n      stop_on_error: false\n    };\n    content = { ...defaults, ...content };\n    let msg = KernelMessage.createShellMessage(options, content, metadata);\n    return this.sendShellMessage(msg, true, disposeOnDone);\n  }\n\n  /**\n   * Send an `is_complete_request` message.\n   *\n   * #### Notes\n   * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#code-completeness).\n   *\n   * Fulfills with the `is_complete_response` content when the shell reply is\n   * received and validated.\n   */\n  requestIsComplete(\n    content: KernelMessage.IIsCompleteRequest\n  ): Promise<KernelMessage.IIsCompleteReplyMsg> {\n    let options: KernelMessage.IOptions = {\n      msgType: 'is_complete_request',\n      channel: 'shell',\n      username: this._username,\n      session: this._clientId\n    };\n    let msg = KernelMessage.createShellMessage(options, content);\n    return Private.handleShellMessage(this, msg) as Promise<\n      KernelMessage.IIsCompleteReplyMsg\n    >;\n  }\n\n  /**\n   * Send a `comm_info_request` message.\n   *\n   * #### Notes\n   * Fulfills with the `comm_info_reply` content when the shell reply is\n   * received and validated.\n   */\n  requestCommInfo(\n    content: KernelMessage.ICommInfoRequest\n  ): Promise<KernelMessage.ICommInfoReplyMsg> {\n    let options: KernelMessage.IOptions = {\n      msgType: 'comm_info_request',\n      channel: 'shell',\n      username: this._username,\n      session: this._clientId\n    };\n    let msg = KernelMessage.createShellMessage(options, content);\n    return Private.handleShellMessage(this, msg) as Promise<\n      KernelMessage.ICommInfoReplyMsg\n    >;\n  }\n\n  /**\n   * Send an `input_reply` message.\n   *\n   * #### Notes\n   * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#messages-on-the-stdin-router-dealer-sockets).\n   */\n  sendInputReply(content: KernelMessage.IInputReply): void {\n    if (this.status === 'dead') {\n      throw new Error('Kernel is dead');\n    }\n    let options: KernelMessage.IOptions = {\n      msgType: 'input_reply',\n      channel: 'stdin',\n      username: this._username,\n      session: this._clientId\n    };\n    let msg = KernelMessage.createMessage(options, content);\n    if (!this._isReady || !this._ws) {\n      this._pendingMessages.push(msg);\n    } else {\n      this._ws.send(serialize.serialize(msg));\n    }\n    this._anyMessage.emit({ msg, direction: 'send' });\n  }\n\n  /**\n   * Connect to a comm, or create a new one.\n   *\n   * #### Notes\n   * If a client-side comm already exists with the given commId, it is returned.\n   */\n  connectToComm(\n    targetName: string,\n    commId: string = UUID.uuid4()\n  ): Kernel.IComm {\n    if (this._comms.has(commId)) {\n      return this._comms.get(commId);\n    }\n    let comm = new CommHandler(targetName, commId, this, () => {\n      this._unregisterComm(commId);\n    });\n    this._comms.set(commId, comm);\n    return comm;\n  }\n\n  /**\n   * Register a comm target handler.\n   *\n   * @param targetName - The name of the comm target.\n   *\n   * @param callback - The callback invoked for a comm open message.\n   *\n   * @returns A disposable used to unregister the comm target.\n   *\n   * #### Notes\n   * Only one comm target can be registered to a target name at a time, an\n   * existing callback for the same target name will be overridden.  A registered\n   * comm target handler will take precedence over a comm which specifies a\n   * `target_module`.\n   *\n   * If the callback returns a promise, kernel message processing will pause\n   * until the returned promise is fulfilled.\n   */\n  registerCommTarget(\n    targetName: string,\n    callback: (\n      comm: Kernel.IComm,\n      msg: KernelMessage.ICommOpenMsg\n    ) => void | PromiseLike<void>\n  ): void {\n    this._targetRegistry[targetName] = callback;\n  }\n\n  /**\n   * Remove a comm target handler.\n   *\n   * @param targetName - The name of the comm target to remove.\n   *\n   * @param callback - The callback to remove.\n   *\n   * #### Notes\n   * The comm target is only removed the callback argument matches.\n   */\n  removeCommTarget(\n    targetName: string,\n    callback: (\n      comm: Kernel.IComm,\n      msg: KernelMessage.ICommOpenMsg\n    ) => void | PromiseLike<void>\n  ): void {\n    if (!this.isDisposed && this._targetRegistry[targetName] === callback) {\n      delete this._targetRegistry[targetName];\n    }\n  }\n\n  /**\n   * Register an IOPub message hook.\n   *\n   * @param msg_id - The parent_header message id the hook will intercept.\n   *\n   * @param hook - The callback invoked for the message.\n   *\n   * #### Notes\n   * The IOPub hook system allows you to preempt the handlers for IOPub\n   * messages that are responses to a given message id.\n   *\n   * The most recently registered hook is run first. A hook can return a\n   * boolean or a promise to a boolean, in which case all kernel message\n   * processing pauses until the promise is fulfilled. If a hook return value\n   * resolves to false, any later hooks will not run and the function will\n   * return a promise resolving to false. If a hook throws an error, the error\n   * is logged to the console and the next hook is run. If a hook is\n   * registered during the hook processing, it will not run until the next\n   * message. If a hook is removed during the hook processing, it will be\n   * deactivated immediately.\n   *\n   * See also [[IFuture.registerMessageHook]].\n   */\n  registerMessageHook(\n    msgId: string,\n    hook: (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>\n  ): void {\n    let future = this._futures && this._futures.get(msgId);\n    if (future) {\n      future.registerMessageHook(hook);\n    }\n  }\n\n  /**\n   * Remove an IOPub message hook.\n   *\n   * @param msg_id - The parent_header message id the hook intercepted.\n   *\n   * @param hook - The callback invoked for the message.\n   *\n   */\n  removeMessageHook(\n    msgId: string,\n    hook: (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>\n  ): void {\n    let future = this._futures && this._futures.get(msgId);\n    if (future) {\n      future.removeMessageHook(hook);\n    }\n  }\n\n  /**\n   * Handle a message with a display id.\n   *\n   * @returns Whether the message was handled.\n   */\n  private async _handleDisplayId(\n    displayId: string,\n    msg: KernelMessage.IMessage\n  ): Promise<boolean> {\n    let msgId = (msg.parent_header as KernelMessage.IHeader).msg_id;\n    let parentIds = this._displayIdToParentIds.get(displayId);\n    if (parentIds) {\n      // We've seen it before, update existing outputs with same display_id\n      // by handling display_data as update_display_data.\n      let updateMsg: KernelMessage.IMessage = {\n        header: JSONExt.deepCopy(msg.header) as KernelMessage.IHeader,\n        parent_header: JSONExt.deepCopy(\n          msg.parent_header\n        ) as KernelMessage.IHeader,\n        metadata: JSONExt.deepCopy(msg.metadata),\n        content: JSONExt.deepCopy(msg.content),\n        channel: msg.channel,\n        buffers: msg.buffers ? msg.buffers.slice() : []\n      };\n      (updateMsg.header as any).msg_type = 'update_display_data';\n\n      await Promise.all(\n        parentIds.map(async parentId => {\n          let future = this._futures && this._futures.get(parentId);\n          if (future) {\n            await future.handleMsg(updateMsg);\n          }\n        })\n      );\n    }\n\n    // We're done here if it's update_display.\n    if (msg.header.msg_type === 'update_display_data') {\n      // It's an update, don't proceed to the normal display.\n      return true;\n    }\n\n    // Regular display_data with id, record it for future updating\n    // in _displayIdToParentIds for future lookup.\n    parentIds = this._displayIdToParentIds.get(displayId) || [];\n    if (parentIds.indexOf(msgId) === -1) {\n      parentIds.push(msgId);\n    }\n    this._displayIdToParentIds.set(displayId, parentIds);\n\n    // Add to our map of display ids for this message.\n    let displayIds = this._msgIdToDisplayIds.get(msgId) || [];\n    if (displayIds.indexOf(msgId) === -1) {\n      displayIds.push(msgId);\n    }\n    this._msgIdToDisplayIds.set(msgId, displayIds);\n\n    // Let the message propagate to the intended recipient.\n    return false;\n  }\n\n  /**\n   * Clear the socket state.\n   */\n  private _clearSocket(): void {\n    this._wsStopped = true;\n    this._isReady = false;\n    if (this._ws !== null) {\n      // Clear the websocket event handlers and the socket itself.\n      this._ws.onopen = this._noOp;\n      this._ws.onclose = this._noOp;\n      this._ws.onerror = this._noOp;\n      this._ws.onmessage = this._noOp;\n      this._ws.close();\n      this._ws = null;\n    }\n  }\n\n  /**\n   * Handle status iopub messages from the kernel.\n   */\n  private _updateStatus(status: Kernel.Status): void {\n    switch (status) {\n      case 'starting':\n      case 'idle':\n      case 'busy':\n      case 'connected':\n        this._isReady = true;\n        break;\n      case 'restarting':\n      case 'reconnecting':\n      case 'dead':\n        this._isReady = false;\n        break;\n      default:\n        console.error('invalid kernel status:', status);\n        return;\n    }\n    if (status !== this._status) {\n      this._status = status;\n      Private.logKernelStatus(this);\n      this._statusChanged.emit(status);\n      if (status === 'dead') {\n        this.dispose();\n      }\n    }\n    if (this._isReady) {\n      this._sendPending();\n    }\n  }\n\n  /**\n   * Send pending messages to the kernel.\n   */\n  private _sendPending(): void {\n    // We shift the message off the queue\n    // after the message is sent so that if there is an exception,\n    // the message is still pending.\n    while (this._ws && this._pendingMessages.length > 0) {\n      let msg = serialize.serialize(this._pendingMessages[0]);\n      this._ws.send(msg);\n      this._pendingMessages.shift();\n    }\n  }\n\n  /**\n   * Clear the internal state.\n   */\n  private _clearState(): void {\n    this._isReady = false;\n    this._pendingMessages = [];\n    this._futures.forEach(future => {\n      future.dispose();\n    });\n    this._comms.forEach(comm => {\n      comm.dispose();\n    });\n    this._msgChain = Promise.resolve();\n    this._kernelSession = '';\n    this._futures = new Map<string, KernelFutureHandler>();\n    this._comms = new Map<string, Kernel.IComm>();\n    this._displayIdToParentIds.clear();\n    this._msgIdToDisplayIds.clear();\n  }\n\n  /**\n   * Check to make sure it is okay to proceed to handle a message.\n   *\n   * #### Notes\n   * Because we handle messages asynchronously, before a message is handled the\n   * kernel might be disposed or restarted (and have a different session id).\n   * This function throws an error in each of these cases. This is meant to be\n   * called at the start of an asynchronous message handler to cancel message\n   * processing if the message no longer is valid.\n   */\n  private _assertCurrentMessage(msg: KernelMessage.IMessage) {\n    if (this.isDisposed) {\n      throw new Error('Kernel object is disposed');\n    }\n\n    if (msg.header.session !== this._kernelSession) {\n      throw new Error(\n        `Canceling handling of old message: ${msg.header.msg_type}`\n      );\n    }\n  }\n\n  /**\n   * Handle a `comm_open` kernel message.\n   */\n  private async _handleCommOpen(\n    msg: KernelMessage.ICommOpenMsg\n  ): Promise<void> {\n    this._assertCurrentMessage(msg);\n    let content = msg.content;\n    let comm = new CommHandler(\n      content.target_name,\n      content.comm_id,\n      this,\n      () => {\n        this._unregisterComm(content.comm_id);\n      }\n    );\n    this._comms.set(content.comm_id, comm);\n\n    try {\n      let target = await Private.loadObject(\n        content.target_name,\n        content.target_module,\n        this._targetRegistry\n      );\n      await target(comm, msg);\n    } catch (e) {\n      // Close the comm asynchronously. We cannot block message processing on\n      // kernel messages to wait for another kernel message.\n      comm.close();\n      console.error('Exception opening new comm');\n      throw e;\n    }\n  }\n\n  /**\n   * Handle 'comm_close' kernel message.\n   */\n  private async _handleCommClose(\n    msg: KernelMessage.ICommCloseMsg\n  ): Promise<void> {\n    this._assertCurrentMessage(msg);\n    let content = msg.content;\n    let comm = this._comms.get(content.comm_id);\n    if (!comm) {\n      console.error('Comm not found for comm id ' + content.comm_id);\n      return;\n    }\n    this._unregisterComm(comm.commId);\n    let onClose = comm.onClose;\n    if (onClose) {\n      await onClose(msg);\n    }\n    (comm as CommHandler).dispose();\n  }\n\n  /**\n   * Handle a 'comm_msg' kernel message.\n   */\n  private async _handleCommMsg(msg: KernelMessage.ICommMsgMsg): Promise<void> {\n    this._assertCurrentMessage(msg);\n    let content = msg.content;\n    let comm = this._comms.get(content.comm_id);\n    if (!comm) {\n      return;\n    }\n    let onMsg = comm.onMsg;\n    if (onMsg) {\n      await onMsg(msg);\n    }\n  }\n\n  /**\n   * Unregister a comm instance.\n   */\n  private _unregisterComm(commId: string) {\n    this._comms.delete(commId);\n  }\n\n  /**\n   * Create the kernel websocket connection and add socket status handlers.\n   */\n  private _createSocket = () => {\n    let settings = this.serverSettings;\n    let partialUrl = URLExt.join(\n      settings.wsUrl,\n      KERNEL_SERVICE_URL,\n      encodeURIComponent(this._id)\n    );\n\n    // Strip any authentication from the display string.\n    // TODO - Audit tests for extra websockets started\n    let display = partialUrl.replace(/^((?:\\w+:)?\\/\\/)(?:[^@\\/]+@)/, '$1');\n    console.log('Starting WebSocket:', display);\n\n    let url = URLExt.join(\n      partialUrl,\n      'channels?session_id=' + encodeURIComponent(this._clientId)\n    );\n    // If token authentication is in use.\n    let token = settings.token;\n    if (token !== '') {\n      url = url + `&token=${encodeURIComponent(token)}`;\n    }\n\n    this._connectionPromise = new PromiseDelegate<void>();\n    this._wsStopped = false;\n    this._ws = new settings.WebSocket(url);\n\n    // Ensure incoming binary messages are not Blobs\n    this._ws.binaryType = 'arraybuffer';\n\n    this._ws.onmessage = this._onWSMessage;\n    this._ws.onopen = this._onWSOpen;\n    this._ws.onclose = this._onWSClose;\n    this._ws.onerror = this._onWSClose;\n  };\n\n  /**\n   * Handle a websocket open event.\n   */\n  private _onWSOpen = (evt: Event) => {\n    this._reconnectAttempt = 0;\n    // Allow the message to get through.\n    this._isReady = true;\n    // Update our status to connected.\n    this._updateStatus('connected');\n    // Get the kernel info, signaling that the kernel is ready.\n    // TODO: requestKernelInfo shouldn't make a request, but should return cached info?\n    this.requestKernelInfo()\n      .then(() => {\n        this._connectionPromise.resolve(void 0);\n      })\n      .catch(err => {\n        this._connectionPromise.reject(err);\n      });\n    this._isReady = false;\n  };\n\n  /**\n   * Handle a websocket message, validating and routing appropriately.\n   */\n  private _onWSMessage = (evt: MessageEvent) => {\n    if (this._wsStopped) {\n      // If the socket is being closed, ignore any messages\n      return;\n    }\n\n    // Notify immediately if there is an error with the message.\n    let msg: KernelMessage.IMessage;\n    try {\n      msg = serialize.deserialize(evt.data);\n      validate.validateMessage(msg);\n    } catch (error) {\n      error.message = `Kernel message validation error: ${error.message}`;\n      // We throw the error so that it bubbles up to the top, and displays the right stack.\n      throw error;\n    }\n\n    // Update the current kernel session id\n    this._kernelSession = msg.header.session;\n\n    // Handle the message asynchronously, in the order received.\n    this._msgChain = this._msgChain\n      .then(() => {\n        // Return so that any promises from handling a message are fulfilled\n        // before proceeding to the next message.\n        return this._handleMessage(msg);\n      })\n      .catch(error => {\n        // Log any errors in handling the message, thus resetting the _msgChain\n        // promise so we can process more messages.\n        console.error(error);\n      });\n\n    // Emit the message receive signal\n    this._anyMessage.emit({ msg, direction: 'recv' });\n  };\n\n  private async _handleMessage(msg: KernelMessage.IMessage): Promise<void> {\n    let handled = false;\n\n    // Check to see if we have a display_id we need to reroute.\n    if (msg.parent_header && msg.channel === 'iopub') {\n      switch (msg.header.msg_type) {\n        case 'display_data':\n        case 'update_display_data':\n        case 'execute_result':\n          // display_data messages may re-route based on their display_id.\n          let transient = (msg.content.transient || {}) as JSONObject;\n          let displayId = transient['display_id'] as string;\n          if (displayId) {\n            handled = await this._handleDisplayId(displayId, msg);\n            // The await above may make this message out of date, so check again.\n            this._assertCurrentMessage(msg);\n          }\n          break;\n        default:\n          break;\n      }\n    }\n\n    if (!handled && msg.parent_header) {\n      let parentHeader = msg.parent_header as KernelMessage.IHeader;\n      let future = this._futures && this._futures.get(parentHeader.msg_id);\n      if (future) {\n        await future.handleMsg(msg);\n        this._assertCurrentMessage(msg);\n      } else {\n        // If the message was sent by us and was not iopub, it is orphaned.\n        let owned = parentHeader.session === this.clientId;\n        if (msg.channel !== 'iopub' && owned) {\n          this._unhandledMessage.emit(msg);\n        }\n      }\n    }\n    if (msg.channel === 'iopub') {\n      switch (msg.header.msg_type) {\n        case 'status':\n          // Updating the status is synchronous, and we call no async user code\n          this._updateStatus(\n            (msg as KernelMessage.IStatusMsg).content.execution_state\n          );\n          break;\n        case 'comm_open':\n          await this._handleCommOpen(msg as KernelMessage.ICommOpenMsg);\n          break;\n        case 'comm_msg':\n          await this._handleCommMsg(msg as KernelMessage.ICommMsgMsg);\n          break;\n        case 'comm_close':\n          await this._handleCommClose(msg as KernelMessage.ICommCloseMsg);\n          break;\n        default:\n          break;\n      }\n      // If the message was a status dead message, we might have disposed ourselves.\n      if (!this.isDisposed) {\n        this._assertCurrentMessage(msg);\n        // the message wouldn't be emitted if we were disposed anyway.\n        this._iopubMessage.emit(msg as KernelMessage.IIOPubMessage);\n      }\n    }\n  }\n\n  /**\n   * Handle a websocket close event.\n   */\n  private _onWSClose = (evt: Event) => {\n    if (this._wsStopped || !this._ws) {\n      return;\n    }\n    // Clear the websocket event handlers and the socket itself.\n    this._clearSocket();\n\n    if (this._reconnectAttempt < this._reconnectLimit) {\n      this._updateStatus('reconnecting');\n      let timeout = Math.pow(2, this._reconnectAttempt);\n      console.error(\n        'Connection lost, reconnecting in ' + timeout + ' seconds.'\n      );\n      setTimeout(this._createSocket, 1e3 * timeout);\n      this._reconnectAttempt += 1;\n    } else {\n      this._updateStatus('dead');\n      this._connectionPromise.reject(\n        new Error('Could not establish connection')\n      );\n    }\n  };\n\n  private _id = '';\n  private _name = '';\n  private _status: Kernel.Status = 'unknown';\n  private _kernelSession = '';\n  private _clientId = '';\n  private _isDisposed = false;\n  private _wsStopped = false;\n  private _ws: WebSocket | null = null;\n  private _username = '';\n  private _reconnectLimit = 7;\n  private _reconnectAttempt = 0;\n  private _isReady = false;\n  private _futures: Map<string, KernelFutureHandler>;\n  private _comms: Map<string, Kernel.IComm>;\n  private _targetRegistry: {\n    [key: string]: (\n      comm: Kernel.IComm,\n      msg: KernelMessage.ICommOpenMsg\n    ) => void;\n  } = Object.create(null);\n  private _info: KernelMessage.IInfoReply | null = null;\n  private _pendingMessages: KernelMessage.IMessage[] = [];\n  private _connectionPromise: PromiseDelegate<void>;\n  private _specPromise: Promise<Kernel.ISpecModel>;\n  private _statusChanged = new Signal<this, Kernel.Status>(this);\n  private _iopubMessage = new Signal<this, KernelMessage.IIOPubMessage>(this);\n  private _anyMessage = new Signal<this, Kernel.IAnyMessageArgs>(this);\n  private _unhandledMessage = new Signal<this, KernelMessage.IMessage>(this);\n  private _displayIdToParentIds = new Map<string, string[]>();\n  private _msgIdToDisplayIds = new Map<string, string[]>();\n  private _terminated = new Signal<this, void>(this);\n  private _msgChain: Promise<void> | null = Promise.resolve();\n  private _noOp = () => {\n    /* no-op */\n  };\n}\n\n/**\n * The namespace for `DefaultKernel` statics.\n */\nexport namespace DefaultKernel {\n  /**\n   * Find a kernel by id.\n   *\n   * @param id - The id of the kernel of interest.\n   *\n   * @param settings - The optional server settings.\n   *\n   * @returns A promise that resolves with the model for the kernel.\n   *\n   * #### Notes\n   * If the kernel was already started via `startNewKernel`, we return its\n   * `Kernel.IModel`.\n   *\n   * Otherwise, we attempt to find an existing kernel by connecting to the\n   * server. The promise is fulfilled when the kernel is found, otherwise the\n   * promise is rejected.\n   */\n  export function findById(\n    id: string,\n    settings?: ServerConnection.ISettings\n  ): Promise<Kernel.IModel> {\n    return Private.findById(id, settings);\n  }\n\n  /**\n   * Fetch all of the kernel specs.\n   *\n   * @param settings - The optional server settings.\n   *\n   * @returns A promise that resolves with the kernel specs.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernelspecs).\n   */\n  export function getSpecs(\n    settings?: ServerConnection.ISettings\n  ): Promise<Kernel.ISpecModels> {\n    return Private.getSpecs(settings);\n  }\n\n  /**\n   * Fetch the running kernels.\n   *\n   * @param settings - The optional server settings.\n   *\n   * @returns A promise that resolves with the list of running kernels.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels) and validates the response model.\n   *\n   * The promise is fulfilled on a valid response and rejected otherwise.\n   */\n  export function listRunning(\n    settings?: ServerConnection.ISettings\n  ): Promise<Kernel.IModel[]> {\n    return Private.listRunning(settings);\n  }\n\n  /**\n   * Start a new kernel.\n   *\n   * @param options - The options used to create the kernel.\n   *\n   * @returns A promise that resolves with a kernel object.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels) and validates the response model.\n   *\n   * If no options are given or the kernel name is not given, the\n   * default kernel will by started by the server.\n   *\n   * Wraps the result in a Kernel object. The promise is fulfilled\n   * when the kernel is started by the server, otherwise the promise is rejected.\n   */\n  export function startNew(options: Kernel.IOptions): Promise<Kernel.IKernel> {\n    return Private.startNew(options);\n  }\n\n  /**\n   * Connect to a running kernel.\n   *\n   * @param model - The model of the running kernel.\n   *\n   * @param settings - The server settings for the request.\n   *\n   * @returns The kernel object.\n   *\n   * #### Notes\n   * If the kernel was already started via `startNewKernel`, the existing\n   * Kernel object info is used to create another instance.\n   */\n  export function connectTo(\n    model: Kernel.IModel,\n    settings?: ServerConnection.ISettings\n  ): Kernel.IKernel {\n    return Private.connectTo(model, settings);\n  }\n\n  /**\n   * Shut down a kernel by id.\n   *\n   * @param id - The id of the running kernel.\n   *\n   * @param settings - The server settings for the request.\n   *\n   * @returns A promise that resolves when the kernel is shut down.\n   */\n  export function shutdown(\n    id: string,\n    settings?: ServerConnection.ISettings\n  ): Promise<void> {\n    return Private.shutdownKernel(id, settings);\n  }\n\n  /**\n   * Shut down all kernels.\n   *\n   * @param settings - The server settings to use.\n   *\n   * @returns A promise that resolves when all the kernels are shut down.\n   */\n  export function shutdownAll(\n    settings?: ServerConnection.ISettings\n  ): Promise<void> {\n    return Private.shutdownAll(settings);\n  }\n}\n\n/**\n * A private namespace for the Kernel.\n */\nnamespace Private {\n  /**\n   * A module private store for running kernels.\n   */\n  export const runningKernels: DefaultKernel[] = [];\n\n  /**\n   * A module private store of kernel specs by base url.\n   */\n  export const specs: {\n    [key: string]: Promise<Kernel.ISpecModels>;\n  } = Object.create(null);\n\n  /**\n   * Find a kernel by id.\n   *\n   * Will reach out to the server if needed to find the kernel.\n   */\n  export function findById(\n    id: string,\n    settings?: ServerConnection.ISettings\n  ): Promise<Kernel.IModel> {\n    let kernel = find(runningKernels, value => {\n      return value.id === id;\n    });\n    if (kernel) {\n      return Promise.resolve(kernel.model);\n    }\n    return getKernelModel(id, settings).catch(() => {\n      throw new Error(`No running kernel with id: ${id}`);\n    });\n  }\n\n  /**\n   * Get the cached kernel specs or fetch them.\n   */\n  export function findSpecs(\n    settings?: ServerConnection.ISettings\n  ): Promise<Kernel.ISpecModels> {\n    settings = settings || ServerConnection.makeSettings();\n    let promise = specs[settings.baseUrl];\n    if (promise) {\n      return promise;\n    }\n    return getSpecs(settings);\n  }\n\n  /**\n   * Fetch all of the kernel specs.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernelspecs).\n   */\n  export function getSpecs(\n    settings?: ServerConnection.ISettings\n  ): Promise<Kernel.ISpecModels> {\n    settings = settings || ServerConnection.makeSettings();\n    let url = URLExt.join(settings.baseUrl, KERNELSPEC_SERVICE_URL);\n    let promise = ServerConnection.makeRequest(url, {}, settings)\n      .then(response => {\n        if (response.status !== 200) {\n          throw new ServerConnection.ResponseError(response);\n        }\n        return response.json();\n      })\n      .then(data => {\n        return validate.validateSpecModels(data);\n      });\n    Private.specs[settings.baseUrl] = promise;\n    return promise;\n  }\n\n  /**\n   * Fetch the running kernels.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels) and validates the response model.\n   *\n   * The promise is fulfilled on a valid response and rejected otherwise.\n   */\n  export function listRunning(\n    settings?: ServerConnection.ISettings\n  ): Promise<Kernel.IModel[]> {\n    settings = settings || ServerConnection.makeSettings();\n    let url = URLExt.join(settings.baseUrl, KERNEL_SERVICE_URL);\n    return ServerConnection.makeRequest(url, {}, settings)\n      .then(response => {\n        if (response.status !== 200) {\n          throw new ServerConnection.ResponseError(response);\n        }\n        return response.json();\n      })\n      .then(data => {\n        if (!Array.isArray(data)) {\n          throw new Error('Invalid kernel list');\n        }\n        for (let i = 0; i < data.length; i++) {\n          validate.validateModel(data[i]);\n        }\n        return updateRunningKernels(data);\n      });\n  }\n\n  /**\n   * Update the running kernels based on new data from the server.\n   */\n  export function updateRunningKernels(\n    kernels: Kernel.IModel[]\n  ): Kernel.IModel[] {\n    each(runningKernels.slice(), kernel => {\n      let updated = find(kernels, model => {\n        return kernel.id === model.id;\n      });\n      // If kernel is no longer running on disk, emit dead signal.\n      if (!updated && kernel.status !== 'dead') {\n        kernel.dispose();\n      }\n    });\n    return kernels;\n  }\n\n  /**\n   * Start a new kernel.\n   */\n  export async function startNew(\n    options: Kernel.IOptions\n  ): Promise<Kernel.IKernel> {\n    let settings = options.serverSettings || ServerConnection.makeSettings();\n    let url = URLExt.join(settings.baseUrl, KERNEL_SERVICE_URL);\n    let init = {\n      method: 'POST',\n      body: JSON.stringify({ name: options.name })\n    };\n    let response = await ServerConnection.makeRequest(url, init, settings);\n    if (response.status !== 201) {\n      throw new ServerConnection.ResponseError(response);\n    }\n    let data = await response.json();\n    validate.validateModel(data);\n    return new DefaultKernel(\n      {\n        ...options,\n        name: data.name,\n        serverSettings: settings\n      },\n      data.id\n    );\n  }\n\n  /**\n   * Connect to a running kernel.\n   */\n  export function connectTo(\n    model: Kernel.IModel,\n    settings?: ServerConnection.ISettings\n  ): Kernel.IKernel {\n    let serverSettings = settings || ServerConnection.makeSettings();\n    let kernel = find(runningKernels, value => {\n      return value.id === model.id;\n    });\n    if (kernel) {\n      return kernel.clone();\n    }\n\n    return new DefaultKernel({ name: model.name, serverSettings }, model.id);\n  }\n\n  /**\n   * Restart a kernel.\n   */\n  export async function restartKernel(\n    kernel: Kernel.IKernel,\n    settings?: ServerConnection.ISettings\n  ): Promise<void> {\n    if (kernel.status === 'dead') {\n      throw new Error('Kernel is dead');\n    }\n    settings = settings || ServerConnection.makeSettings();\n    let url = URLExt.join(\n      settings.baseUrl,\n      KERNEL_SERVICE_URL,\n      encodeURIComponent(kernel.id),\n      'restart'\n    );\n    let init = { method: 'POST' };\n\n    // TODO: If we handleRestart before making the server request, we sever the\n    // communication link before the shutdown_reply message comes, so we end up\n    // getting the shutdown_reply messages after we reconnect, which is weird.\n    // We might want to move the handleRestart to after we get the response back\n\n    // Handle the restart on all of the kernels with the same id.\n    each(runningKernels, k => {\n      if (k.id === kernel.id) {\n        k.handleRestart();\n      }\n    });\n    let response = await ServerConnection.makeRequest(url, init, settings);\n    if (response.status !== 200) {\n      throw new ServerConnection.ResponseError(response);\n    }\n    let data = await response.json();\n    validate.validateModel(data);\n    // Reconnect the other kernels asynchronously, but don't wait for them.\n    each(runningKernels, k => {\n      if (k !== kernel && k.id === kernel.id) {\n        k.reconnect();\n      }\n    });\n    await kernel.reconnect();\n  }\n\n  /**\n   * Interrupt a kernel.\n   */\n  export async function interruptKernel(\n    kernel: Kernel.IKernel,\n    settings?: ServerConnection.ISettings\n  ): Promise<void> {\n    if (kernel.status === 'dead') {\n      throw new Error('Kernel is dead');\n    }\n    settings = settings || ServerConnection.makeSettings();\n    let url = URLExt.join(\n      settings.baseUrl,\n      KERNEL_SERVICE_URL,\n      encodeURIComponent(kernel.id),\n      'interrupt'\n    );\n    let init = { method: 'POST' };\n    let response = await ServerConnection.makeRequest(url, init, settings);\n    if (response.status !== 204) {\n      throw new ServerConnection.ResponseError(response);\n    }\n  }\n\n  /**\n   * Delete a kernel.\n   */\n  export async function shutdownKernel(\n    id: string,\n    settings?: ServerConnection.ISettings\n  ): Promise<void> {\n    settings = settings || ServerConnection.makeSettings();\n    let url = URLExt.join(\n      settings.baseUrl,\n      KERNEL_SERVICE_URL,\n      encodeURIComponent(id)\n    );\n    let init = { method: 'DELETE' };\n    let response = await ServerConnection.makeRequest(url, init, settings);\n    if (response.status === 404) {\n      let msg = `The kernel \"${id}\" does not exist on the server`;\n      console.warn(msg);\n    } else if (response.status !== 204) {\n      throw new ServerConnection.ResponseError(response);\n    }\n    killKernels(id);\n  }\n\n  /**\n   * Shut down all kernels.\n   *\n   * @param settings - The server settings to use.\n   *\n   * @returns A promise that resolves when all the kernels are shut down.\n   */\n  export async function shutdownAll(\n    settings?: ServerConnection.ISettings\n  ): Promise<void> {\n    settings = settings || ServerConnection.makeSettings();\n    let running = await listRunning(settings);\n    await Promise.all(running.map(k => shutdownKernel(k.id, settings)));\n  }\n\n  /**\n   * Kill the kernels by id.\n   */\n  function killKernels(id: string): void {\n    // Iterate on an array copy so disposals will not affect the iteration.\n    runningKernels.slice().forEach(kernel => {\n      if (kernel.id === id) {\n        kernel.dispose();\n      }\n    });\n  }\n\n  /**\n   * Get a full kernel model from the server by kernel id string.\n   */\n  export async function getKernelModel(\n    id: string,\n    settings?: ServerConnection.ISettings\n  ): Promise<Kernel.IModel> {\n    settings = settings || ServerConnection.makeSettings();\n    let url = URLExt.join(\n      settings.baseUrl,\n      KERNEL_SERVICE_URL,\n      encodeURIComponent(id)\n    );\n    let response = await ServerConnection.makeRequest(url, {}, settings);\n    if (response.status !== 200) {\n      throw new ServerConnection.ResponseError(response);\n    }\n    let data = await response.json();\n    validate.validateModel(data);\n    return data;\n  }\n\n  /**\n   * Log the current kernel status.\n   */\n  export function logKernelStatus(kernel: Kernel.IKernel): void {\n    switch (kernel.status) {\n      case 'idle':\n      case 'busy':\n      case 'unknown':\n        return;\n      default:\n        console.log(`Kernel: ${kernel.status} (${kernel.id})`);\n        break;\n    }\n  }\n\n  /**\n   * Send a kernel message to the kernel and resolve the reply message.\n   */\n  export async function handleShellMessage(\n    kernel: Kernel.IKernel,\n    msg: KernelMessage.IShellMessage\n  ): Promise<KernelMessage.IShellMessage> {\n    let future = kernel.sendShellMessage(msg, true);\n    return future.done;\n  }\n\n  /**\n   * Try to load an object from a module or a registry.\n   *\n   * Try to load an object from a module asynchronously if a module\n   * is specified, otherwise tries to load an object from the global\n   * registry, if the global registry is provided.\n   */\n  export function loadObject(\n    name: string,\n    moduleName: string | undefined,\n    registry?: { [key: string]: any }\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      // Try loading the view module using require.js\n      if (moduleName) {\n        if (typeof requirejs === 'undefined') {\n          throw new Error('requirejs not found');\n        }\n        requirejs(\n          [moduleName],\n          (mod: any) => {\n            if (mod[name] === void 0) {\n              let msg = `Object '${name}' not found in module '${moduleName}'`;\n              reject(new Error(msg));\n            } else {\n              resolve(mod[name]);\n            }\n          },\n          reject\n        );\n      } else {\n        if (registry && registry[name]) {\n          resolve(registry[name]);\n        } else {\n          reject(new Error(`Object '${name}' not found in registry`));\n        }\n      }\n    });\n  }\n}\n"]}