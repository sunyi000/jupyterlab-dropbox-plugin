{"version":3,"file":"future.js","sourceRoot":"","sources":["../../../../../services/src/kernel/future.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { PromiseDelegate } from '@phosphor/coreutils';\n\nimport { DisposableDelegate } from '@phosphor/disposable';\n\nimport { Kernel } from './kernel';\n\nimport { KernelMessage } from './messages';\n\n/**\n * Implementation of a kernel future.\n *\n * If a reply is expected, the Future is considered done when both a `reply`\n * message and an `idle` iopub status message have been received.  Otherwise, it\n * is considered done when the `idle` status is received.\n *\n */\nexport class KernelFutureHandler extends DisposableDelegate\n  implements Kernel.IFuture {\n  /**\n   * Construct a new KernelFutureHandler.\n   */\n  constructor(\n    cb: () => void,\n    msg: KernelMessage.IShellMessage,\n    expectReply: boolean,\n    disposeOnDone: boolean,\n    kernel: Kernel.IKernel\n  ) {\n    super(cb);\n    this._msg = msg;\n    if (!expectReply) {\n      this._setFlag(Private.KernelFutureFlag.GotReply);\n    }\n    this._disposeOnDone = disposeOnDone;\n    this._kernel = kernel;\n  }\n\n  /**\n   * Get the original outgoing message.\n   */\n  get msg(): KernelMessage.IShellMessage {\n    return this._msg;\n  }\n\n  /**\n   * A promise that resolves when the future is done.\n   */\n  get done(): Promise<KernelMessage.IShellMessage> {\n    return this._done.promise;\n  }\n\n  /**\n   * Get the reply handler.\n   */\n  get onReply(): (\n    msg: KernelMessage.IShellMessage\n  ) => void | PromiseLike<void> {\n    return this._reply;\n  }\n\n  /**\n   * Set the reply handler.\n   */\n  set onReply(\n    cb: (msg: KernelMessage.IShellMessage) => void | PromiseLike<void>\n  ) {\n    this._reply = cb;\n  }\n\n  /**\n   * Get the iopub handler.\n   */\n  get onIOPub(): (\n    msg: KernelMessage.IIOPubMessage\n  ) => void | PromiseLike<void> {\n    return this._iopub;\n  }\n\n  /**\n   * Set the iopub handler.\n   */\n  set onIOPub(\n    cb: (msg: KernelMessage.IIOPubMessage) => void | PromiseLike<void>\n  ) {\n    this._iopub = cb;\n  }\n\n  /**\n   * Get the stdin handler.\n   */\n  get onStdin(): (\n    msg: KernelMessage.IStdinMessage\n  ) => void | PromiseLike<void> {\n    return this._stdin;\n  }\n\n  /**\n   * Set the stdin handler.\n   */\n  set onStdin(\n    cb: (msg: KernelMessage.IStdinMessage) => void | PromiseLike<void>\n  ) {\n    this._stdin = cb;\n  }\n\n  /**\n   * Register hook for IOPub messages.\n   *\n   * @param hook - The callback invoked for an IOPub message.\n   *\n   * #### Notes\n   * The IOPub hook system allows you to preempt the handlers for IOPub\n   * messages handled by the future.\n   *\n   * The most recently registered hook is run first. A hook can return a\n   * boolean or a promise to a boolean, in which case all kernel message\n   * processing pauses until the promise is fulfilled. If a hook return value\n   * resolves to false, any later hooks will not run and the function will\n   * return a promise resolving to false. If a hook throws an error, the error\n   * is logged to the console and the next hook is run. If a hook is\n   * registered during the hook processing, it will not run until the next\n   * message. If a hook is removed during the hook processing, it will be\n   * deactivated immediately.\n   */\n  registerMessageHook(\n    hook: (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>\n  ): void {\n    if (this.isDisposed) {\n      throw new Error('Kernel future is disposed');\n    }\n    this._hooks.add(hook);\n  }\n\n  /**\n   * Remove a hook for IOPub messages.\n   *\n   * @param hook - The hook to remove.\n   *\n   * #### Notes\n   * If a hook is removed during the hook processing, it will be deactivated immediately.\n   */\n  removeMessageHook(\n    hook: (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>\n  ): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._hooks.remove(hook);\n  }\n\n  /**\n   * Send an `input_reply` message.\n   */\n  sendInputReply(content: KernelMessage.IInputReply): void {\n    this._kernel.sendInputReply(content);\n  }\n\n  /**\n   * Dispose and unregister the future.\n   */\n  dispose(): void {\n    this._stdin = Private.noOp;\n    this._iopub = Private.noOp;\n    this._reply = Private.noOp;\n    this._hooks = null;\n    if (!this._testFlag(Private.KernelFutureFlag.IsDone)) {\n      // Reject the `done` promise, but catch its error here in case no one else\n      // is waiting for the promise to resolve. This prevents the error from\n      // being displayed in the console, but does not prevent it from being\n      // caught by a client who is waiting for it.\n      this._done.reject(new Error('Canceled'));\n      this._done.promise.catch(() => {\n        /* no-op */\n      });\n\n      // TODO: Uncomment the following logging code, and check for any tests that trigger it.\n      // let status = [];\n      // if (!this._testFlag(Private.KernelFutureFlag.GotIdle)) {\n      //   status.push('idle');\n      // }\n      // if (!this._testFlag(Private.KernelFutureFlag.GotReply)) {\n      //   status.push('reply');\n      // }\n      // console.warn(`*************** DISPOSED BEFORE DONE: K${this._kernel.id.slice(0, 6)} M${this._msg.header.msg_id.slice(0, 6)} missing ${status.join(' ')}`);\n    }\n    super.dispose();\n  }\n\n  /**\n   * Handle an incoming kernel message.\n   */\n  async handleMsg(msg: KernelMessage.IMessage): Promise<void> {\n    switch (msg.channel) {\n      case 'shell':\n        await this._handleReply(msg as KernelMessage.IShellMessage);\n        break;\n      case 'stdin':\n        await this._handleStdin(msg as KernelMessage.IStdinMessage);\n        break;\n      case 'iopub':\n        await this._handleIOPub(msg as KernelMessage.IIOPubMessage);\n        break;\n      default:\n        break;\n    }\n  }\n\n  private async _handleReply(msg: KernelMessage.IShellMessage): Promise<void> {\n    let reply = this._reply;\n    if (reply) {\n      await reply(msg);\n    }\n    this._replyMsg = msg;\n    this._setFlag(Private.KernelFutureFlag.GotReply);\n    if (this._testFlag(Private.KernelFutureFlag.GotIdle)) {\n      this._handleDone();\n    }\n  }\n\n  private async _handleStdin(msg: KernelMessage.IStdinMessage): Promise<void> {\n    let stdin = this._stdin;\n    if (stdin) {\n      await stdin(msg);\n    }\n  }\n\n  private async _handleIOPub(msg: KernelMessage.IIOPubMessage): Promise<void> {\n    let process = await this._hooks.process(msg);\n    let iopub = this._iopub;\n    if (process && iopub) {\n      await iopub(msg);\n    }\n    if (\n      KernelMessage.isStatusMsg(msg) &&\n      msg.content.execution_state === 'idle'\n    ) {\n      this._setFlag(Private.KernelFutureFlag.GotIdle);\n      if (this._testFlag(Private.KernelFutureFlag.GotReply)) {\n        this._handleDone();\n      }\n    }\n  }\n\n  private _handleDone(): void {\n    if (this._testFlag(Private.KernelFutureFlag.IsDone)) {\n      return;\n    }\n    this._setFlag(Private.KernelFutureFlag.IsDone);\n    this._done.resolve(this._replyMsg);\n    if (this._disposeOnDone) {\n      this.dispose();\n    }\n  }\n\n  /**\n   * Test whether the given future flag is set.\n   */\n  private _testFlag(flag: Private.KernelFutureFlag): boolean {\n    // tslint:disable-next-line\n    return (this._status & flag) !== 0;\n  }\n\n  /**\n   * Set the given future flag.\n   */\n  private _setFlag(flag: Private.KernelFutureFlag): void {\n    // tslint:disable-next-line\n    this._status |= flag;\n  }\n\n  private _msg: KernelMessage.IShellMessage;\n  private _status = 0;\n  private _stdin: (\n    msg: KernelMessage.IStdinMessage\n  ) => void | PromiseLike<void> = Private.noOp;\n  private _iopub: (\n    msg: KernelMessage.IIOPubMessage\n  ) => void | PromiseLike<void> = Private.noOp;\n  private _reply: (\n    msg: KernelMessage.IShellMessage\n  ) => void | PromiseLike<void> = Private.noOp;\n  private _done = new PromiseDelegate<KernelMessage.IShellMessage>();\n  private _replyMsg: KernelMessage.IShellMessage;\n  private _hooks = new Private.HookList<KernelMessage.IIOPubMessage>();\n  private _disposeOnDone = true;\n  private _kernel: Kernel.IKernel;\n}\n\nnamespace Private {\n  /**\n   * A no-op function.\n   */\n  export const noOp = () => {\n    /* no-op */\n  };\n\n  /**\n   * Defer a computation.\n   *\n   * #### NOTES\n   * We can't just use requestAnimationFrame since it is not available in node.\n   * This implementation is from Phosphor:\n   * https://github.com/phosphorjs/phosphor/blob/e88e4321289bb1198f3098e7bda40736501f2ed8/tests/test-messaging/src/index.spec.ts#L63\n   */\n  const defer = (() => {\n    let ok = typeof requestAnimationFrame === 'function';\n    return ok ? requestAnimationFrame : setImmediate;\n  })();\n\n  export class HookList<T> {\n    /**\n     * Register a hook.\n     *\n     * @param hook - The callback to register.\n     */\n    add(hook: (msg: T) => boolean | PromiseLike<boolean>): void {\n      this.remove(hook);\n      this._hooks.push(hook);\n    }\n\n    /**\n     * Remove a hook, if it exists in the hook list.\n     *\n     * @param hook - The callback to remove.\n     */\n    remove(hook: (msg: T) => boolean | PromiseLike<boolean>): void {\n      let index = this._hooks.indexOf(hook);\n      if (index >= 0) {\n        this._hooks[index] = null;\n        this._scheduleCompact();\n      }\n    }\n\n    /**\n     * Process a message through the hooks.\n     *\n     * @returns a promise resolving to false if any hook resolved as false,\n     * otherwise true\n     *\n     * #### Notes\n     * The most recently registered hook is run first. A hook can return a\n     * boolean or a promise to a boolean, in which case processing pauses until\n     * the promise is fulfilled. If a hook return value resolves to false, any\n     * later hooks will not run and the function will return a promise resolving\n     * to false. If a hook throws an error, the error is logged to the console\n     * and the next hook is run. If a hook is registered during the hook\n     * processing, it will not run until the next message. If a hook is removed\n     * during the hook processing, it will be deactivated immediately.\n     */\n    async process(msg: T): Promise<boolean> {\n      // Wait until we can start a new process run.\n      await this._processing;\n\n      // Start the next process run.\n      let processing = new PromiseDelegate<void>();\n      this._processing = processing.promise;\n\n      let continueHandling: boolean;\n\n      // Call the end hook (most recently-added) first. Starting at the end also\n      // guarantees that hooks added during the processing will not be run in\n      // this process run.\n      for (let i = this._hooks.length - 1; i >= 0; i--) {\n        let hook = this._hooks[i];\n\n        // If the hook has been removed, continue to the next one.\n        if (hook === null) {\n          continue;\n        }\n\n        // Execute the hook and log any errors.\n        try {\n          continueHandling = await hook(msg);\n        } catch (err) {\n          continueHandling = true;\n          console.error(err);\n        }\n\n        // If the hook resolved to false, stop processing and return.\n        if (continueHandling === false) {\n          processing.resolve(undefined);\n          return false;\n        }\n      }\n\n      // All hooks returned true (or errored out), so return true.\n      processing.resolve(undefined);\n      return true;\n    }\n\n    /**\n     * Schedule a cleanup of the list, removing any hooks that have been nulled out.\n     */\n    private _scheduleCompact(): void {\n      if (!this._compactScheduled) {\n        this._compactScheduled = true;\n\n        // Schedule a compaction in between processing runs. We do the\n        // scheduling in an animation frame to rate-limit our compactions. If we\n        // need to compact more frequently, we can change this to directly\n        // schedule the compaction.\n        defer(() => {\n          this._processing = this._processing.then(() => {\n            this._compactScheduled = false;\n            this._compact();\n          });\n        });\n      }\n    }\n\n    /**\n     * Compact the list, removing any nulls.\n     */\n    private _compact(): void {\n      let numNulls = 0;\n      for (let i = 0, len = this._hooks.length; i < len; i++) {\n        let hook = this._hooks[i];\n        if (this._hooks[i] === null) {\n          numNulls++;\n        } else {\n          this._hooks[i - numNulls] = hook;\n        }\n      }\n      this._hooks.length -= numNulls;\n    }\n\n    private _hooks: (\n      | ((msg: T) => boolean | PromiseLike<boolean>)\n      | null)[] = [];\n    private _compactScheduled: boolean;\n    private _processing: Promise<void>;\n  }\n\n  /**\n   * Bit flags for the kernel future state.\n   */\n  export enum KernelFutureFlag {\n    GotReply = 0x1,\n    GotIdle = 0x2,\n    IsDone = 0x4,\n    DisposeOnDone = 0x8\n  }\n}\n"]}