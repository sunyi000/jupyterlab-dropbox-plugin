{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../services/src/contents/index.ts"],"names":[],"mappings":";AAAA,0CAA0C;AAC1C,2DAA2D;;;;;;;;;AAE3D,qDAAwD;AAMxD,mDAA2C;AAI3C,mDAAsD;AAEtD,0BAAsC;AAEtC,qDAAuC;AAEvC;;GAEG;AACH,MAAM,iBAAiB,GAAG,cAAc,CAAC;AAEzC;;GAEG;AACH,MAAM,SAAS,GAAG,OAAO,CAAC;AAE1B;;GAEG;AACH,IAAiB,QAAQ,CA+dxB;AA/dD,WAAiB,QAAQ;IAoEvB;;OAEG;IACH,+BAAsC,QAAgB;QACpD,QAAQ,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;IAC3C,CAAC;IAFe,8BAAqB,wBAEpC,CAAA;IAwED;;OAEG;IACH,iCAAwC,UAA4B;QAClE,QAAQ,CAAC,uBAAuB,CAAC,UAAU,CAAC,CAAC;IAC/C,CAAC;IAFe,gCAAuB,0BAEtC,CAAA;AAyUH,CAAC,EA/dgB,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QA+dxB;AAED;;;;;;;GAOG;AACH;IACE;;;;OAIG;IACH,YAAY,UAAoC,EAAE;QA8X1C,gBAAW,GAAG,KAAK,CAAC;QACpB,sBAAiB,GAAG,IAAI,GAAG,EAA2B,CAAC;QAEvD,iBAAY,GAAG,IAAI,kBAAM,CAA8B,IAAI,CAAC,CAAC;QAhYnE,IAAI,cAAc,GAAG,CAAC,IAAI,CAAC,cAAc;YACvC,OAAO,CAAC,cAAc,IAAI,oBAAgB,CAAC,YAAY,EAAE,CAAC,CAAC;QAC7D,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,YAAY,IAAI,IAAI,KAAK,CAAC,EAAE,cAAc,EAAE,CAAC,CAAC;QAC3E,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;IACpE,CAAC;IAOD;;OAEG;IACH,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED;;OAEG;IACH,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED;;OAEG;IACH,OAAO;QACL,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,OAAO;SACR;QACD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,kBAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACzB,CAAC;IAED;;OAEG;IACH,QAAQ,CAAC,KAAsB;QAC7B,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAC9C,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;IACvD,CAAC;IAED;;;;OAIG;IACH,iBAAiB,CAAC,IAAY;QAC5B,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QACvC,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,cAAc,CAAC,IAAI,IAAI,CAAC;IACjD,CAAC;IAED;;;;;;;OAOG;IACH,SAAS,CAAC,IAAY;QACpB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC9B,MAAM,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACvC,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;YACzE,OAAO,mBAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;SAClC;QACD,OAAO,mBAAO,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACxE,CAAC;IAED;;;;;;;;OAQG;IACH,SAAS,CAAC,IAAY;QACpB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC9B,MAAM,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACvC,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;YAC3B,OAAO,EAAE,CAAC;SACX;QACD,IAAI,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;YAC7C,OAAO,UAAU,CAAC,CAAC,CAAC,CAAC;SACtB;QACD,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;;;;;;;OAQG;IACH,GAAG,CACD,IAAY,EACZ,OAAgC;QAEhC,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAClD,OAAO,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;YACxD,IAAI,OAAO,GAAsB,EAAE,CAAC;YACpC,IAAI,aAAa,CAAC,IAAI,KAAK,WAAW,IAAI,aAAa,CAAC,OAAO,EAAE;gBAC/D,gBAAI,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC,IAAqB,EAAE,EAAE;oBACpD,OAAO,CAAC,IAAI,CAAC,kBACR,IAAI,IACP,IAAI,EAAE,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,GACxB,CAAC,CAAC;gBACxB,CAAC,CAAC,CAAC;gBACH,OAAO,kBACF,aAAa,IAChB,IAAI,EAAE,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,SAAS,CAAC,EAC1C,OAAO,EAAE,OAAO,GACE,CAAC;aACtB;iBAAM;gBACL,OAAO,kBACF,aAAa,IAChB,IAAI,EAAE,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,SAAS,CAAC,GACxB,CAAC;aACtB;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;OAOG;IACH,cAAc,CAAC,IAAY;QACzB,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAClD,OAAO,KAAK,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;IACzC,CAAC;IAED;;;;;;;OAOG;IACH,WAAW,CAAC,UAAmC,EAAE;QAC/C,IAAI,OAAO,CAAC,IAAI,EAAE;YAChB,IAAI,UAAU,GAAG,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YACjD,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;YACxD,OAAO,KAAK;iBACT,WAAW,mBAAM,OAAO,IAAE,IAAI,EAAE,SAAS,IAAG;iBAC5C,IAAI,CAAC,aAAa,CAAC,EAAE;gBACpB,OAAO,kBACF,aAAa,IAChB,IAAI,EAAE,mBAAO,CAAC,IAAI,CAAC,UAAU,EAAE,aAAa,CAAC,IAAI,CAAC,GAChC,CAAC;YACvB,CAAC,CAAC,CAAC;SACN;aAAM;YACL,OAAO,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;SAChD;IACH,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,IAAY;QACjB,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAClD,OAAO,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;IACjC,CAAC;IAED;;;;;;;;;OASG;IACH,MAAM,CAAC,IAAY,EAAE,OAAe;QAClC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC/C,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAClD,IAAI,MAAM,KAAK,MAAM,EAAE;YACrB,MAAM,KAAK,CAAC,2DAA2D,CAAC,CAAC;SAC1E;QACD,OAAO,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;YACtD,OAAO,kBACF,aAAa,IAChB,IAAI,EAAE,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,KAAK,CAAC,GACrB,CAAC;QACvB,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,IAAI,CACF,IAAY,EACZ,UAAoC,EAAE;QAEtC,MAAM,UAAU,GAAG,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QAC3C,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QACpD,OAAO,KAAK;aACT,IAAI,CAAC,SAAS,oBAAO,OAAO,IAAE,IAAI,EAAE,SAAS,IAAG;aAChD,IAAI,CAAC,aAAa,CAAC,EAAE;YACpB,OAAO,kBAAK,aAAa,IAAE,IAAI,EAAE,UAAU,GAAqB,CAAC;QACnE,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,IAAI,CAAC,QAAgB,EAAE,KAAa;QAClC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;QACnD,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QAChD,IAAI,MAAM,KAAK,MAAM,EAAE;YACrB,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;gBACpD,OAAO,kBACF,aAAa,IAChB,IAAI,EAAE,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,aAAa,CAAC,IAAI,CAAC,GAClC,CAAC;YACvB,CAAC,CAAC,CAAC;SACJ;aAAM;YACL,MAAM,KAAK,CAAC,2DAA2D,CAAC,CAAC;SAC1E;IACH,CAAC;IAED;;;;;;;OAOG;IACH,gBAAgB,CAAC,IAAY;QAC3B,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAClD,OAAO,KAAK,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;IAC3C,CAAC;IAED;;;;;;;OAOG;IACH,eAAe,CAAC,IAAY;QAC1B,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAClD,OAAO,KAAK,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;IAC1C,CAAC;IAED;;;;;;;;OAQG;IACH,iBAAiB,CAAC,IAAY,EAAE,YAAoB;QAClD,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAClD,OAAO,KAAK,CAAC,iBAAiB,CAAC,SAAS,EAAE,YAAY,CAAC,CAAC;IAC1D,CAAC;IAED;;;;;;;;OAQG;IACH,gBAAgB,CAAC,IAAY,EAAE,YAAoB;QACjD,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAClD,OAAO,KAAK,CAAC,gBAAgB,CAAC,SAAS,EAAE,YAAY,CAAC,CAAC;IACzD,CAAC;IAED;;;;;;;;;OASG;IACK,aAAa,CAAC,KAAsB,EAAE,SAAiB;QAC7D,IAAI,KAAK,KAAK,IAAI,CAAC,aAAa,EAAE;YAChC,OAAO,mBAAO,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;SACvC;aAAM;YACL,OAAO,GAAG,KAAK,CAAC,IAAI,IAAI,mBAAO,CAAC,WAAW,CAAC,SAAS,CAAC,EAAE,CAAC;SAC1D;IACH,CAAC;IAED;;;;;;;;;;OAUG;IACK,aAAa,CAAC,IAAY;QAChC,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACvC,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACvC,IAAI,SAAS,EAAE;YACb,OAAO,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,SAAS,CAAC,CAAC;SAC3D;aAAM;YACL,OAAO,CAAC,IAAI,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;SACxC;IACH,CAAC;IAED;;;;OAIG;IACK,cAAc,CAAC,MAAuB,EAAE,IAA2B;QACzE,IAAI,MAAM,KAAK,IAAI,CAAC,aAAa,EAAE;YACjC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC9B;aAAM;YACL,IAAI,QAAQ,GAAoC,IAAI,CAAC;YACrD,IAAI,QAAQ,GAAoC,IAAI,CAAC;YACrD,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE;gBACvC,QAAQ,qBACH,IAAI,CAAC,QAAQ,IAChB,IAAI,EAAE,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GACrD,CAAC;aACH;YACD,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE;gBACvC,QAAQ,qBACH,IAAI,CAAC,QAAQ,IAChB,IAAI,EAAE,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GACrD,CAAC;aACH;YACD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;gBACrB,IAAI,EAAE,IAAI,CAAC,IAAI;gBACf,QAAQ;gBACR,QAAQ;aACT,CAAC,CAAC;SACJ;IACH,CAAC;CAMF;AAxYD,0CAwYC;AAED;;;GAGG;AACH;IACE;;;;OAIG;IACH,YAAY,UAA0B,EAAE;QA8ZhC,gBAAW,GAAG,KAAK,CAAC;QACpB,iBAAY,GAAG,IAAI,kBAAM,CAA8B,IAAI,CAAC,CAAC;QA9ZnE,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,IAAI,SAAS,CAAC;QACtC,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,WAAW,IAAI,iBAAiB,CAAC;QAC7D,IAAI,CAAC,cAAc;YACjB,OAAO,CAAC,cAAc,IAAI,oBAAgB,CAAC,YAAY,EAAE,CAAC;IAC9D,CAAC;IAQD;;OAEG;IACH,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAOD;;OAEG;IACH,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED;;OAEG;IACH,OAAO;QACL,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,OAAO;SACR;QACD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,kBAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACzB,CAAC;IAED;;;;;;;;;;OAUG;IACH,GAAG,CACD,SAAiB,EACjB,OAAgC;QAEhC,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAClC,IAAI,OAAO,EAAE;YACX,kDAAkD;YAClD,IAAI,OAAO,CAAC,IAAI,KAAK,UAAU,EAAE;gBAC/B,OAAO,OAAO,CAAC,QAAQ,CAAC,CAAC;aAC1B;YACD,IAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;YAC1C,IAAI,MAAM,qBAAoB,OAAO,IAAE,OAAO,GAAE,CAAC;YACjD,GAAG,IAAI,kBAAM,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;SAC3C;QAED,IAAI,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC;QACnC,OAAO,oBAAgB,CAAC,WAAW,CAAC,GAAG,EAAE,EAAE,EAAE,QAAQ,CAAC;aACnD,IAAI,CAAC,QAAQ,CAAC,EAAE;YACf,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;gBAC3B,MAAM,IAAI,oBAAgB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aACpD;YACD,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC;QACzB,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,EAAE;YACX,QAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;YACrC,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;OAOG;IACH,cAAc,CAAC,SAAiB;QAC9B,IAAI,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC;QAC1C,OAAO,OAAO,CAAC,OAAO,CACpB,kBAAM,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,EAAE,kBAAM,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAC/D,CAAC;IACJ,CAAC;IAED;;;;;;;;;;OAUG;IACH,WAAW,CAAC,UAAmC,EAAE;QAC/C,IAAI,IAAI,GAAG,IAAI,CAAC;QAChB,IAAI,OAAO,EAAE;YACX,IAAI,OAAO,CAAC,GAAG,EAAE;gBACf,OAAO,CAAC,GAAG,GAAG,OAAO,CAAC,kBAAkB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;aACvD;YACD,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;SAChC;QAED,IAAI,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC;QACnC,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC;QAC3C,IAAI,IAAI,GAAG;YACT,MAAM,EAAE,MAAM;YACd,IAAI;SACL,CAAC;QACF,OAAO,oBAAgB,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,EAAE,QAAQ,CAAC;aACrD,IAAI,CAAC,QAAQ,CAAC,EAAE;YACf,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;gBAC3B,MAAM,IAAI,oBAAgB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aACpD;YACD,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC;QACzB,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,EAAE;YACX,QAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;YACrC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;gBACrB,IAAI,EAAE,KAAK;gBACX,QAAQ,EAAE,IAAI;gBACd,QAAQ,EAAE,IAAI;aACf,CAAC,CAAC;YACH,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;;OASG;IACH,MAAM,CAAC,SAAiB;QACtB,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAClC,IAAI,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC;QACnC,IAAI,IAAI,GAAG,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC;QAChC,OAAO,oBAAgB,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YACvE,kDAAkD;YAClD,2DAA2D;YAC3D,wDAAwD;YACxD,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;gBAC3B,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;oBACjC,MAAM,IAAI,oBAAgB,CAAC,aAAa,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;gBACtE,CAAC,CAAC,CAAC;aACJ;YACD,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;gBAC3B,MAAM,IAAI,oBAAgB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aACpD;YACD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;gBACrB,IAAI,EAAE,QAAQ;gBACd,QAAQ,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE;gBAC7B,QAAQ,EAAE,IAAI;aACf,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,MAAM,CAAC,YAAoB,EAAE,YAAoB;QAC/C,IAAI,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC;QACnC,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QACrC,IAAI,IAAI,GAAG;YACT,MAAM,EAAE,OAAO;YACf,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,YAAY,EAAE,CAAC;SAC7C,CAAC;QACF,OAAO,oBAAgB,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,EAAE,QAAQ,CAAC;aACrD,IAAI,CAAC,QAAQ,CAAC,EAAE;YACf,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;gBAC3B,MAAM,IAAI,oBAAgB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aACpD;YACD,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC;QACzB,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,EAAE;YACX,QAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;YACrC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;gBACrB,IAAI,EAAE,QAAQ;gBACd,QAAQ,EAAE,EAAE,IAAI,EAAE,YAAY,EAAE;gBAChC,QAAQ,EAAE,IAAI;aACf,CAAC,CAAC;YACH,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,IAAI,CACF,SAAiB,EACjB,UAAoC,EAAE;QAEtC,IAAI,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC;QACnC,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAClC,IAAI,IAAI,GAAG;YACT,MAAM,EAAE,KAAK;YACb,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;SAC9B,CAAC;QACF,OAAO,oBAAgB,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,EAAE,QAAQ,CAAC;aACrD,IAAI,CAAC,QAAQ,CAAC,EAAE;YACf,8DAA8D;YAC9D,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;gBACtD,MAAM,IAAI,oBAAgB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aACpD;YACD,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC;QACzB,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,EAAE;YACX,QAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;YACrC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;gBACrB,IAAI,EAAE,MAAM;gBACZ,QAAQ,EAAE,IAAI;gBACd,QAAQ,EAAE,IAAI;aACf,CAAC,CAAC;YACH,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,IAAI,CAAC,QAAgB,EAAE,KAAa;QAClC,IAAI,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC;QACnC,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAC9B,IAAI,IAAI,GAAG;YACT,MAAM,EAAE,MAAM;YACd,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,CAAC;SAC9C,CAAC;QACF,OAAO,oBAAgB,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,EAAE,QAAQ,CAAC;aACrD,IAAI,CAAC,QAAQ,CAAC,EAAE;YACf,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;gBAC3B,MAAM,IAAI,oBAAgB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aACpD;YACD,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC;QACzB,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,EAAE;YACX,QAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;YACrC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;gBACrB,IAAI,EAAE,KAAK;gBACX,QAAQ,EAAE,IAAI;gBACd,QAAQ,EAAE,IAAI;aACf,CAAC,CAAC;YACH,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;;;OAUG;IACH,gBAAgB,CAAC,SAAiB;QAChC,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;QACjD,IAAI,IAAI,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC;QAC9B,OAAO,oBAAgB,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,cAAc,CAAC;aAChE,IAAI,CAAC,QAAQ,CAAC,EAAE;YACf,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;gBAC3B,MAAM,IAAI,oBAAgB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aACpD;YACD,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC;QACzB,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,EAAE;YACX,QAAQ,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;YACvC,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;;;OAUG;IACH,eAAe,CAAC,SAAiB;QAC/B,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;QACjD,OAAO,oBAAgB,CAAC,WAAW,CAAC,GAAG,EAAE,EAAE,EAAE,IAAI,CAAC,cAAc,CAAC;aAC9D,IAAI,CAAC,QAAQ,CAAC,EAAE;YACf,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;gBAC3B,MAAM,IAAI,oBAAgB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aACpD;YACD,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC;QACzB,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,EAAE;YACX,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBACxB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;aAC5C;YACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACpC,QAAQ,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;aAC3C;YACD,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;;;;OAWG;IACH,iBAAiB,CAAC,SAAiB,EAAE,YAAoB;QACvD,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,aAAa,EAAE,YAAY,CAAC,CAAC;QAC/D,IAAI,IAAI,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC;QAC9B,OAAO,oBAAgB,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC,IAAI,CACtE,QAAQ,CAAC,EAAE;YACT,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;gBAC3B,MAAM,IAAI,oBAAgB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aACpD;QACH,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;OAWG;IACH,gBAAgB,CAAC,SAAiB,EAAE,YAAoB;QACtD,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,aAAa,EAAE,YAAY,CAAC,CAAC;QAC/D,IAAI,IAAI,GAAG,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC;QAChC,OAAO,oBAAgB,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC,IAAI,CACtE,QAAQ,CAAC,EAAE;YACT,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;gBAC3B,MAAM,IAAI,oBAAgB,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aACpD;QACH,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;OAEG;IACK,OAAO,CAAC,GAAG,IAAc;QAC/B,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,kBAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC;QACvD,IAAI,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC;QAC1C,OAAO,kBAAM,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,YAAY,EAAE,GAAG,KAAK,CAAC,CAAC;IAC3D,CAAC;CAKF;AAtaD,sBAsaC;AAkDD;;GAEG;AACH,IAAU,OAAO,CAyBhB;AAzBD,WAAU,OAAO;IACf;;;;OAIG;IACH,4BAAmC,SAAiB;QAClD,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,IAAI,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YACxD,SAAS,GAAG,IAAI,SAAS,EAAE,CAAC;SAC7B;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IALe,0BAAkB,qBAKjC,CAAA;IAED;;;;OAIG;IACH,mBAA0B,IAAY;QACpC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC9B,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACtB,OAAO,mBAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;SAChC;QACD,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,mBAAO,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC;IACtE,CAAC;IANe,iBAAS,YAMxB,CAAA;AACH,CAAC,EAzBS,OAAO,KAAP,OAAO,QAyBhB","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { URLExt, PathExt } from '@jupyterlab/coreutils';\n\nimport { ModelDB } from '@jupyterlab/observables';\n\nimport { JSONObject } from '@phosphor/coreutils';\n\nimport { each } from '@phosphor/algorithm';\n\nimport { IDisposable } from '@phosphor/disposable';\n\nimport { ISignal, Signal } from '@phosphor/signaling';\n\nimport { ServerConnection } from '..';\n\nimport * as validate from './validate';\n\n/**\n * The url for the default drive service.\n */\nconst SERVICE_DRIVE_URL = 'api/contents';\n\n/**\n * The url for the file access.\n */\nconst FILES_URL = 'files';\n\n/**\n * A namespace for contents interfaces.\n */\nexport namespace Contents {\n  /**\n   * A contents model.\n   */\n  export interface IModel {\n    /**\n     * Name of the contents file.\n     *\n     * #### Notes\n     *  Equivalent to the last part of the `path` field.\n     */\n    readonly name: string;\n\n    /**\n     * The full file path.\n     *\n     * #### Notes\n     * It will *not* start with `/`, and it will be `/`-delimited.\n     */\n    readonly path: string;\n\n    /**\n     * The type of file.\n     */\n    readonly type: ContentType;\n\n    /**\n     * Whether the requester has permission to edit the file.\n     */\n    readonly writable: boolean;\n\n    /**\n     * File creation timestamp.\n     */\n    readonly created: string;\n\n    /**\n     * Last modified timestamp.\n     */\n    readonly last_modified: string;\n\n    /**\n     * Specify the mime-type of file contents.\n     *\n     * #### Notes\n     * Only non-`null` when `content` is present and `type` is `\"file\"`.\n     */\n    readonly mimetype: string;\n\n    /**\n     * The optional file content.\n     */\n    readonly content: any;\n\n    /**\n     * The chunk of the file upload.\n     */\n    readonly chunk?: number;\n\n    /**\n     * The format of the file `content`.\n     *\n     * #### Notes\n     * Only relevant for type: 'file'\n     */\n    readonly format: FileFormat;\n  }\n\n  /**\n   * Validates an IModel, thowing an error if it does not pass.\n   */\n  export function validateContentsModel(contents: IModel): void {\n    validate.validateContentsModel(contents);\n  }\n\n  /**\n   * A contents file type.\n   */\n  export type ContentType = 'notebook' | 'file' | 'directory';\n\n  /**\n   * A contents file format.\n   */\n  export type FileFormat = 'json' | 'text' | 'base64';\n\n  /**\n   * The options used to fetch a file.\n   */\n  export interface IFetchOptions {\n    /**\n     * The override file type for the request.\n     */\n    type?: ContentType;\n\n    /**\n     * The override file format for the request.\n     */\n    format?: FileFormat;\n\n    /**\n     * Whether to include the file content.\n     *\n     * The default is `true`.\n     */\n    content?: boolean;\n  }\n\n  /**\n   * The options used to create a file.\n   */\n  export interface ICreateOptions {\n    /**\n     * The directory in which to create the file.\n     */\n    path?: string;\n\n    /**\n     * The optional file extension for the new file (e.g. `\".txt\"`).\n     *\n     * #### Notes\n     * This ignored if `type` is `'notebook'`.\n     */\n    ext?: string;\n\n    /**\n     * The file type.\n     */\n    type?: ContentType;\n  }\n\n  /**\n   * Checkpoint model.\n   */\n  export interface ICheckpointModel {\n    /**\n     * The unique identifier for the checkpoint.\n     */\n    readonly id: string;\n\n    /**\n     * Last modified timestamp.\n     */\n    readonly last_modified: string;\n  }\n\n  /**\n   * Validates an ICheckpointModel, thowing an error if it does not pass.\n   */\n  export function validateCheckpointModel(checkpoint: ICheckpointModel): void {\n    validate.validateCheckpointModel(checkpoint);\n  }\n\n  /**\n   * The change args for a file change.\n   */\n  export interface IChangedArgs {\n    /**\n     * The type of change.\n     */\n    type: 'new' | 'delete' | 'rename' | 'save';\n\n    /**\n     * The new contents.\n     */\n    oldValue: Partial<IModel> | null;\n\n    /**\n     * The old contents.\n     */\n    newValue: Partial<IModel> | null;\n  }\n\n  /**\n   * The interface for a contents manager.\n   */\n  export interface IManager extends IDisposable {\n    /**\n     * A signal emitted when a file operation takes place.\n     */\n    readonly fileChanged: ISignal<IManager, IChangedArgs>;\n\n    /**\n     * The server settings associated with the manager.\n     */\n    readonly serverSettings: ServerConnection.ISettings;\n\n    /**\n     * Add an `IDrive` to the manager.\n     */\n    addDrive(drive: IDrive): void;\n\n    /**\n     * Given a path of the form `drive:local/portion/of/it.txt`\n     * get the local part of it.\n     *\n     * @param path: the path.\n     *\n     * @returns The local part of the path.\n     */\n    localPath(path: string): string;\n\n    /**\n     * Given a path of the form `drive:local/portion/of/it.txt`\n     * get the name of the drive. If the path is missing\n     * a drive portion, returns an empty string.\n     *\n     * @param path: the path.\n     *\n     * @returns The drive name for the path, or the empty string.\n     */\n    driveName(path: string): string;\n\n    /**\n     * Given a path, get a ModelDB.IFactory from the\n     * relevant backend. Returns `null` if the backend\n     * does not provide one.\n     */\n    getModelDBFactory(path: string): ModelDB.IFactory | null;\n\n    /**\n     * Get a file or directory.\n     *\n     * @param path: The path to the file.\n     *\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    get(path: string, options?: IFetchOptions): Promise<IModel>;\n\n    /**\n     * Get an encoded download url given a file path.\n     *\n     * @param A promise which resolves with the absolute POSIX\n     *   file path on the server.\n     */\n    getDownloadUrl(path: string): Promise<string>;\n\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the\n     *    file is created.\n     */\n    newUntitled(options?: ICreateOptions): Promise<IModel>;\n\n    /**\n     * Delete a file.\n     *\n     * @param path - The path to the file.\n     *\n     * @returns A promise which resolves when the file is deleted.\n     */\n    delete(path: string): Promise<void>;\n\n    /**\n     * Rename a file or directory.\n     *\n     * @param path - The original file path.\n     *\n     * @param newPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the\n     *   file is renamed.\n     */\n    rename(path: string, newPath: string): Promise<IModel>;\n\n    /**\n     * Save a file.\n     *\n     * @param path - The desired file path.\n     *\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the\n     *   file is saved.\n     */\n    save(path: string, options?: Partial<IModel>): Promise<IModel>;\n\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param path - The original file path.\n     *\n     * @param toDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new content model when the\n     *  file is copied.\n     */\n    copy(path: string, toDir: string): Promise<IModel>;\n\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    createCheckpoint(path: string): Promise<ICheckpointModel>;\n\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    listCheckpoints(path: string): Promise<ICheckpointModel[]>;\n\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param path - The path of the file.\n     *\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    restoreCheckpoint(path: string, checkpointID: string): Promise<void>;\n\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    deleteCheckpoint(path: string, checkpointID: string): Promise<void>;\n  }\n\n  /**\n   * The interface for a network drive that can be mounted\n   * in the contents manager.\n   */\n  export interface IDrive extends IDisposable {\n    /**\n     * The name of the drive, which is used at the leading\n     * component of file paths.\n     */\n    readonly name: string;\n\n    /**\n     * The server settings of the manager.\n     */\n    readonly serverSettings: ServerConnection.ISettings;\n\n    /**\n     * An optional ModelDB.IFactory instance for the\n     * drive.\n     */\n    readonly modelDBFactory?: ModelDB.IFactory;\n\n    /**\n     * A signal emitted when a file operation takes place.\n     */\n    fileChanged: ISignal<IDrive, IChangedArgs>;\n\n    /**\n     * Get a file or directory.\n     *\n     * @param localPath: The path to the file.\n     *\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    get(localPath: string, options?: IFetchOptions): Promise<IModel>;\n\n    /**\n     * Get an encoded download url given a file path.\n     *\n     * @param A promise which resolves with the absolute POSIX\n     *   file path on the server.\n     */\n    getDownloadUrl(localPath: string): Promise<string>;\n\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the\n     *    file is created.\n     */\n    newUntitled(options?: ICreateOptions): Promise<IModel>;\n\n    /**\n     * Delete a file.\n     *\n     * @param localPath - The path to the file.\n     *\n     * @returns A promise which resolves when the file is deleted.\n     */\n    delete(localPath: string): Promise<void>;\n\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldLocalPath - The original file path.\n     *\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the\n     *   file is renamed.\n     */\n    rename(oldLocalPath: string, newLocalPath: string): Promise<IModel>;\n\n    /**\n     * Save a file.\n     *\n     * @param localPath - The desired file path.\n     *\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the\n     *   file is saved.\n     */\n    save(localPath: string, options?: Partial<IModel>): Promise<IModel>;\n\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param localPath - The original file path.\n     *\n     * @param toLocalDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new content model when the\n     *  file is copied.\n     */\n    copy(localPath: string, toLocalDir: string): Promise<IModel>;\n\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param localPath - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    createCheckpoint(localPath: string): Promise<ICheckpointModel>;\n\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param localPath - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    listCheckpoints(localPath: string): Promise<ICheckpointModel[]>;\n\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param localPath - The path of the file.\n     *\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    restoreCheckpoint(localPath: string, checkpointID: string): Promise<void>;\n\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param localPath - The path of the file.\n     *\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    deleteCheckpoint(localPath: string, checkpointID: string): Promise<void>;\n  }\n}\n\n/**\n * A contents manager that passes file operations to the server.\n * Multiple servers implementing the `IDrive` interface can be\n * attached to the contents manager, so that the same session can\n * perform file operations on multiple backends.\n *\n * This includes checkpointing with the normal file operations.\n */\nexport class ContentsManager implements Contents.IManager {\n  /**\n   * Construct a new contents manager object.\n   *\n   * @param options - The options used to initialize the object.\n   */\n  constructor(options: ContentsManager.IOptions = {}) {\n    let serverSettings = (this.serverSettings =\n      options.serverSettings || ServerConnection.makeSettings());\n    this._defaultDrive = options.defaultDrive || new Drive({ serverSettings });\n    this._defaultDrive.fileChanged.connect(this._onFileChanged, this);\n  }\n\n  /**\n   * The server settings associated with the manager.\n   */\n  readonly serverSettings: ServerConnection.ISettings;\n\n  /**\n   * A signal emitted when a file operation takes place.\n   */\n  get fileChanged(): ISignal<this, Contents.IChangedArgs> {\n    return this._fileChanged;\n  }\n\n  /**\n   * Test whether the manager has been disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Dispose of the resources held by the manager.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    Signal.clearData(this);\n  }\n\n  /**\n   * Add an `IDrive` to the manager.\n   */\n  addDrive(drive: Contents.IDrive): void {\n    this._additionalDrives.set(drive.name, drive);\n    drive.fileChanged.connect(this._onFileChanged, this);\n  }\n\n  /**\n   * Given a path, get a ModelDB.IFactory from the\n   * relevant backend. Returns `null` if the backend\n   * does not provide one.\n   */\n  getModelDBFactory(path: string): ModelDB.IFactory | null {\n    let [drive] = this._driveForPath(path);\n    return (drive && drive.modelDBFactory) || null;\n  }\n\n  /**\n   * Given a path of the form `drive:local/portion/of/it.txt`\n   * get the local part of it.\n   *\n   * @param path: the path.\n   *\n   * @returns The local part of the path.\n   */\n  localPath(path: string): string {\n    const parts = path.split('/');\n    const firstParts = parts[0].split(':');\n    if (firstParts.length === 1 || !this._additionalDrives.has(firstParts[0])) {\n      return PathExt.removeSlash(path);\n    }\n    return PathExt.join(firstParts.slice(1).join(':'), ...parts.slice(1));\n  }\n\n  /**\n   * Given a path of the form `drive:local/portion/of/it.txt`\n   * get the name of the drive. If the path is missing\n   * a drive portion, returns an empty string.\n   *\n   * @param path: the path.\n   *\n   * @returns The drive name for the path, or the empty string.\n   */\n  driveName(path: string): string {\n    const parts = path.split('/');\n    const firstParts = parts[0].split(':');\n    if (firstParts.length === 1) {\n      return '';\n    }\n    if (this._additionalDrives.has(firstParts[0])) {\n      return firstParts[0];\n    }\n    return '';\n  }\n\n  /**\n   * Get a file or directory.\n   *\n   * @param path: The path to the file.\n   *\n   * @param options: The options used to fetch the file.\n   *\n   * @returns A promise which resolves with the file content.\n   */\n  get(\n    path: string,\n    options?: Contents.IFetchOptions\n  ): Promise<Contents.IModel> {\n    let [drive, localPath] = this._driveForPath(path);\n    return drive.get(localPath, options).then(contentsModel => {\n      let listing: Contents.IModel[] = [];\n      if (contentsModel.type === 'directory' && contentsModel.content) {\n        each(contentsModel.content, (item: Contents.IModel) => {\n          listing.push({\n            ...item,\n            path: this._toGlobalPath(drive, item.path)\n          } as Contents.IModel);\n        });\n        return {\n          ...contentsModel,\n          path: this._toGlobalPath(drive, localPath),\n          content: listing\n        } as Contents.IModel;\n      } else {\n        return {\n          ...contentsModel,\n          path: this._toGlobalPath(drive, localPath)\n        } as Contents.IModel;\n      }\n    });\n  }\n\n  /**\n   * Get an encoded download url given a file path.\n   *\n   * @param path - An absolute POSIX file path on the server.\n   *\n   * #### Notes\n   * It is expected that the path contains no relative paths.\n   */\n  getDownloadUrl(path: string): Promise<string> {\n    let [drive, localPath] = this._driveForPath(path);\n    return drive.getDownloadUrl(localPath);\n  }\n\n  /**\n   * Create a new untitled file or directory in the specified directory path.\n   *\n   * @param options: The options used to create the file.\n   *\n   * @returns A promise which resolves with the created file content when the\n   *    file is created.\n   */\n  newUntitled(options: Contents.ICreateOptions = {}): Promise<Contents.IModel> {\n    if (options.path) {\n      let globalPath = Private.normalize(options.path);\n      let [drive, localPath] = this._driveForPath(globalPath);\n      return drive\n        .newUntitled({ ...options, path: localPath })\n        .then(contentsModel => {\n          return {\n            ...contentsModel,\n            path: PathExt.join(globalPath, contentsModel.name)\n          } as Contents.IModel;\n        });\n    } else {\n      return this._defaultDrive.newUntitled(options);\n    }\n  }\n\n  /**\n   * Delete a file.\n   *\n   * @param path - The path to the file.\n   *\n   * @returns A promise which resolves when the file is deleted.\n   */\n  delete(path: string): Promise<void> {\n    let [drive, localPath] = this._driveForPath(path);\n    return drive.delete(localPath);\n  }\n\n  /**\n   * Rename a file or directory.\n   *\n   * @param path - The original file path.\n   *\n   * @param newPath - The new file path.\n   *\n   * @returns A promise which resolves with the new file contents model when\n   *   the file is renamed.\n   */\n  rename(path: string, newPath: string): Promise<Contents.IModel> {\n    let [drive1, path1] = this._driveForPath(path);\n    let [drive2, path2] = this._driveForPath(newPath);\n    if (drive1 !== drive2) {\n      throw Error('ContentsManager: renaming files must occur within a Drive');\n    }\n    return drive1.rename(path1, path2).then(contentsModel => {\n      return {\n        ...contentsModel,\n        path: this._toGlobalPath(drive1, path2)\n      } as Contents.IModel;\n    });\n  }\n\n  /**\n   * Save a file.\n   *\n   * @param path - The desired file path.\n   *\n   * @param options - Optional overrides to the model.\n   *\n   * @returns A promise which resolves with the file content model when the\n   *   file is saved.\n   *\n   * #### Notes\n   * Ensure that `model.content` is populated for the file.\n   */\n  save(\n    path: string,\n    options: Partial<Contents.IModel> = {}\n  ): Promise<Contents.IModel> {\n    const globalPath = Private.normalize(path);\n    const [drive, localPath] = this._driveForPath(path);\n    return drive\n      .save(localPath, { ...options, path: localPath })\n      .then(contentsModel => {\n        return { ...contentsModel, path: globalPath } as Contents.IModel;\n      });\n  }\n\n  /**\n   * Copy a file into a given directory.\n   *\n   * @param path - The original file path.\n   *\n   * @param toDir - The destination directory path.\n   *\n   * @returns A promise which resolves with the new contents model when the\n   *  file is copied.\n   *\n   * #### Notes\n   * The server will select the name of the copied file.\n   */\n  copy(fromFile: string, toDir: string): Promise<Contents.IModel> {\n    let [drive1, path1] = this._driveForPath(fromFile);\n    let [drive2, path2] = this._driveForPath(toDir);\n    if (drive1 === drive2) {\n      return drive1.copy(path1, path2).then(contentsModel => {\n        return {\n          ...contentsModel,\n          path: this._toGlobalPath(drive1, contentsModel.path)\n        } as Contents.IModel;\n      });\n    } else {\n      throw Error('Copying files between drives is not currently implemented');\n    }\n  }\n\n  /**\n   * Create a checkpoint for a file.\n   *\n   * @param path - The path of the file.\n   *\n   * @returns A promise which resolves with the new checkpoint model when the\n   *   checkpoint is created.\n   */\n  createCheckpoint(path: string): Promise<Contents.ICheckpointModel> {\n    let [drive, localPath] = this._driveForPath(path);\n    return drive.createCheckpoint(localPath);\n  }\n\n  /**\n   * List available checkpoints for a file.\n   *\n   * @param path - The path of the file.\n   *\n   * @returns A promise which resolves with a list of checkpoint models for\n   *    the file.\n   */\n  listCheckpoints(path: string): Promise<Contents.ICheckpointModel[]> {\n    let [drive, localPath] = this._driveForPath(path);\n    return drive.listCheckpoints(localPath);\n  }\n\n  /**\n   * Restore a file to a known checkpoint state.\n   *\n   * @param path - The path of the file.\n   *\n   * @param checkpointID - The id of the checkpoint to restore.\n   *\n   * @returns A promise which resolves when the checkpoint is restored.\n   */\n  restoreCheckpoint(path: string, checkpointID: string): Promise<void> {\n    let [drive, localPath] = this._driveForPath(path);\n    return drive.restoreCheckpoint(localPath, checkpointID);\n  }\n\n  /**\n   * Delete a checkpoint for a file.\n   *\n   * @param path - The path of the file.\n   *\n   * @param checkpointID - The id of the checkpoint to delete.\n   *\n   * @returns A promise which resolves when the checkpoint is deleted.\n   */\n  deleteCheckpoint(path: string, checkpointID: string): Promise<void> {\n    let [drive, localPath] = this._driveForPath(path);\n    return drive.deleteCheckpoint(localPath, checkpointID);\n  }\n\n  /**\n   * Given a drive and a local path, construct a fully qualified\n   * path. The inverse of `_driveForPath`.\n   *\n   * @param drive: an `IDrive`.\n   *\n   * @param localPath: the local path on the drive.\n   *\n   * @returns the fully qualified path.\n   */\n  private _toGlobalPath(drive: Contents.IDrive, localPath: string): string {\n    if (drive === this._defaultDrive) {\n      return PathExt.removeSlash(localPath);\n    } else {\n      return `${drive.name}:${PathExt.removeSlash(localPath)}`;\n    }\n  }\n\n  /**\n   * Given a path, get the `IDrive to which it refers,\n   * where the path satisfies the pattern\n   * `'driveName:path/to/file'`. If there is no `driveName`\n   * prepended to the path, it returns the default drive.\n   *\n   * @param path: a path to a file.\n   *\n   * @returns A tuple containing an `IDrive` object for the path,\n   * and a local path for that drive.\n   */\n  private _driveForPath(path: string): [Contents.IDrive, string] {\n    const driveName = this.driveName(path);\n    const localPath = this.localPath(path);\n    if (driveName) {\n      return [this._additionalDrives.get(driveName), localPath];\n    } else {\n      return [this._defaultDrive, localPath];\n    }\n  }\n\n  /**\n   * Respond to fileChanged signals from the drives attached to\n   * the manager. This prepends the drive name to the path if necessary,\n   * and then forwards the signal.\n   */\n  private _onFileChanged(sender: Contents.IDrive, args: Contents.IChangedArgs) {\n    if (sender === this._defaultDrive) {\n      this._fileChanged.emit(args);\n    } else {\n      let newValue: Partial<Contents.IModel> | null = null;\n      let oldValue: Partial<Contents.IModel> | null = null;\n      if (args.newValue && args.newValue.path) {\n        newValue = {\n          ...args.newValue,\n          path: this._toGlobalPath(sender, args.newValue.path)\n        };\n      }\n      if (args.oldValue && args.oldValue.path) {\n        oldValue = {\n          ...args.oldValue,\n          path: this._toGlobalPath(sender, args.oldValue.path)\n        };\n      }\n      this._fileChanged.emit({\n        type: args.type,\n        newValue,\n        oldValue\n      });\n    }\n  }\n\n  private _isDisposed = false;\n  private _additionalDrives = new Map<string, Contents.IDrive>();\n  private _defaultDrive: Contents.IDrive;\n  private _fileChanged = new Signal<this, Contents.IChangedArgs>(this);\n}\n\n/**\n * A default implementation for an `IDrive`, talking to the\n * server using the Jupyter REST API.\n */\nexport class Drive implements Contents.IDrive {\n  /**\n   * Construct a new contents manager object.\n   *\n   * @param options - The options used to initialize the object.\n   */\n  constructor(options: Drive.IOptions = {}) {\n    this.name = options.name || 'Default';\n    this._apiEndpoint = options.apiEndpoint || SERVICE_DRIVE_URL;\n    this.serverSettings =\n      options.serverSettings || ServerConnection.makeSettings();\n  }\n\n  /**\n   * The name of the drive, which is used at the leading\n   * component of file paths.\n   */\n  readonly name: string;\n\n  /**\n   * A signal emitted when a file operation takes place.\n   */\n  get fileChanged(): ISignal<this, Contents.IChangedArgs> {\n    return this._fileChanged;\n  }\n\n  /**\n   * The server settings of the drive.\n   */\n  readonly serverSettings: ServerConnection.ISettings;\n\n  /**\n   * Test whether the manager has been disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Dispose of the resources held by the manager.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    Signal.clearData(this);\n  }\n\n  /**\n   * Get a file or directory.\n   *\n   * @param localPath: The path to the file.\n   *\n   * @param options: The options used to fetch the file.\n   *\n   * @returns A promise which resolves with the file content.\n   *\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.\n   */\n  get(\n    localPath: string,\n    options?: Contents.IFetchOptions\n  ): Promise<Contents.IModel> {\n    let url = this._getUrl(localPath);\n    if (options) {\n      // The notebook type cannot take an format option.\n      if (options.type === 'notebook') {\n        delete options['format'];\n      }\n      let content = options.content ? '1' : '0';\n      let params: JSONObject = { ...options, content };\n      url += URLExt.objectToQueryString(params);\n    }\n\n    let settings = this.serverSettings;\n    return ServerConnection.makeRequest(url, {}, settings)\n      .then(response => {\n        if (response.status !== 200) {\n          throw new ServerConnection.ResponseError(response);\n        }\n        return response.json();\n      })\n      .then(data => {\n        validate.validateContentsModel(data);\n        return data;\n      });\n  }\n\n  /**\n   * Get an encoded download url given a file path.\n   *\n   * @param localPath - An absolute POSIX file path on the server.\n   *\n   * #### Notes\n   * It is expected that the path contains no relative paths.\n   */\n  getDownloadUrl(localPath: string): Promise<string> {\n    let baseUrl = this.serverSettings.baseUrl;\n    return Promise.resolve(\n      URLExt.join(baseUrl, FILES_URL, URLExt.encodeParts(localPath))\n    );\n  }\n\n  /**\n   * Create a new untitled file or directory in the specified directory path.\n   *\n   * @param options: The options used to create the file.\n   *\n   * @returns A promise which resolves with the created file content when the\n   *    file is created.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.\n   */\n  newUntitled(options: Contents.ICreateOptions = {}): Promise<Contents.IModel> {\n    let body = '{}';\n    if (options) {\n      if (options.ext) {\n        options.ext = Private.normalizeExtension(options.ext);\n      }\n      body = JSON.stringify(options);\n    }\n\n    let settings = this.serverSettings;\n    let url = this._getUrl(options.path || '');\n    let init = {\n      method: 'POST',\n      body\n    };\n    return ServerConnection.makeRequest(url, init, settings)\n      .then(response => {\n        if (response.status !== 201) {\n          throw new ServerConnection.ResponseError(response);\n        }\n        return response.json();\n      })\n      .then(data => {\n        validate.validateContentsModel(data);\n        this._fileChanged.emit({\n          type: 'new',\n          oldValue: null,\n          newValue: data\n        });\n        return data;\n      });\n  }\n\n  /**\n   * Delete a file.\n   *\n   * @param localPath - The path to the file.\n   *\n   * @returns A promise which resolves when the file is deleted.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents).\n   */\n  delete(localPath: string): Promise<void> {\n    let url = this._getUrl(localPath);\n    let settings = this.serverSettings;\n    let init = { method: 'DELETE' };\n    return ServerConnection.makeRequest(url, init, settings).then(response => {\n      // Translate certain errors to more specific ones.\n      // TODO: update IPEP27 to specify errors more precisely, so\n      // that error types can be detected here with certainty.\n      if (response.status === 400) {\n        return response.json().then(data => {\n          throw new ServerConnection.ResponseError(response, data['message']);\n        });\n      }\n      if (response.status !== 204) {\n        throw new ServerConnection.ResponseError(response);\n      }\n      this._fileChanged.emit({\n        type: 'delete',\n        oldValue: { path: localPath },\n        newValue: null\n      });\n    });\n  }\n\n  /**\n   * Rename a file or directory.\n   *\n   * @param oldLocalPath - The original file path.\n   *\n   * @param newLocalPath - The new file path.\n   *\n   * @returns A promise which resolves with the new file contents model when\n   *   the file is renamed.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.\n   */\n  rename(oldLocalPath: string, newLocalPath: string): Promise<Contents.IModel> {\n    let settings = this.serverSettings;\n    let url = this._getUrl(oldLocalPath);\n    let init = {\n      method: 'PATCH',\n      body: JSON.stringify({ path: newLocalPath })\n    };\n    return ServerConnection.makeRequest(url, init, settings)\n      .then(response => {\n        if (response.status !== 200) {\n          throw new ServerConnection.ResponseError(response);\n        }\n        return response.json();\n      })\n      .then(data => {\n        validate.validateContentsModel(data);\n        this._fileChanged.emit({\n          type: 'rename',\n          oldValue: { path: oldLocalPath },\n          newValue: data\n        });\n        return data;\n      });\n  }\n\n  /**\n   * Save a file.\n   *\n   * @param localPath - The desired file path.\n   *\n   * @param options - Optional overrides to the model.\n   *\n   * @returns A promise which resolves with the file content model when the\n   *   file is saved.\n   *\n   * #### Notes\n   * Ensure that `model.content` is populated for the file.\n   *\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.\n   */\n  save(\n    localPath: string,\n    options: Partial<Contents.IModel> = {}\n  ): Promise<Contents.IModel> {\n    let settings = this.serverSettings;\n    let url = this._getUrl(localPath);\n    let init = {\n      method: 'PUT',\n      body: JSON.stringify(options)\n    };\n    return ServerConnection.makeRequest(url, init, settings)\n      .then(response => {\n        // will return 200 for an existing file and 201 for a new file\n        if (response.status !== 200 && response.status !== 201) {\n          throw new ServerConnection.ResponseError(response);\n        }\n        return response.json();\n      })\n      .then(data => {\n        validate.validateContentsModel(data);\n        this._fileChanged.emit({\n          type: 'save',\n          oldValue: null,\n          newValue: data\n        });\n        return data;\n      });\n  }\n\n  /**\n   * Copy a file into a given directory.\n   *\n   * @param localPath - The original file path.\n   *\n   * @param toDir - The destination directory path.\n   *\n   * @returns A promise which resolves with the new contents model when the\n   *  file is copied.\n   *\n   * #### Notes\n   * The server will select the name of the copied file.\n   *\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.\n   */\n  copy(fromFile: string, toDir: string): Promise<Contents.IModel> {\n    let settings = this.serverSettings;\n    let url = this._getUrl(toDir);\n    let init = {\n      method: 'POST',\n      body: JSON.stringify({ copy_from: fromFile })\n    };\n    return ServerConnection.makeRequest(url, init, settings)\n      .then(response => {\n        if (response.status !== 201) {\n          throw new ServerConnection.ResponseError(response);\n        }\n        return response.json();\n      })\n      .then(data => {\n        validate.validateContentsModel(data);\n        this._fileChanged.emit({\n          type: 'new',\n          oldValue: null,\n          newValue: data\n        });\n        return data;\n      });\n  }\n\n  /**\n   * Create a checkpoint for a file.\n   *\n   * @param localPath - The path of the file.\n   *\n   * @returns A promise which resolves with the new checkpoint model when the\n   *   checkpoint is created.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.\n   */\n  createCheckpoint(localPath: string): Promise<Contents.ICheckpointModel> {\n    let url = this._getUrl(localPath, 'checkpoints');\n    let init = { method: 'POST' };\n    return ServerConnection.makeRequest(url, init, this.serverSettings)\n      .then(response => {\n        if (response.status !== 201) {\n          throw new ServerConnection.ResponseError(response);\n        }\n        return response.json();\n      })\n      .then(data => {\n        validate.validateCheckpointModel(data);\n        return data;\n      });\n  }\n\n  /**\n   * List available checkpoints for a file.\n   *\n   * @param localPath - The path of the file.\n   *\n   * @returns A promise which resolves with a list of checkpoint models for\n   *    the file.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.\n   */\n  listCheckpoints(localPath: string): Promise<Contents.ICheckpointModel[]> {\n    let url = this._getUrl(localPath, 'checkpoints');\n    return ServerConnection.makeRequest(url, {}, this.serverSettings)\n      .then(response => {\n        if (response.status !== 200) {\n          throw new ServerConnection.ResponseError(response);\n        }\n        return response.json();\n      })\n      .then(data => {\n        if (!Array.isArray(data)) {\n          throw new Error('Invalid Checkpoint list');\n        }\n        for (let i = 0; i < data.length; i++) {\n          validate.validateCheckpointModel(data[i]);\n        }\n        return data;\n      });\n  }\n\n  /**\n   * Restore a file to a known checkpoint state.\n   *\n   * @param localPath - The path of the file.\n   *\n   * @param checkpointID - The id of the checkpoint to restore.\n   *\n   * @returns A promise which resolves when the checkpoint is restored.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents).\n   */\n  restoreCheckpoint(localPath: string, checkpointID: string): Promise<void> {\n    let url = this._getUrl(localPath, 'checkpoints', checkpointID);\n    let init = { method: 'POST' };\n    return ServerConnection.makeRequest(url, init, this.serverSettings).then(\n      response => {\n        if (response.status !== 204) {\n          throw new ServerConnection.ResponseError(response);\n        }\n      }\n    );\n  }\n\n  /**\n   * Delete a checkpoint for a file.\n   *\n   * @param localPath - The path of the file.\n   *\n   * @param checkpointID - The id of the checkpoint to delete.\n   *\n   * @returns A promise which resolves when the checkpoint is deleted.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents).\n   */\n  deleteCheckpoint(localPath: string, checkpointID: string): Promise<void> {\n    let url = this._getUrl(localPath, 'checkpoints', checkpointID);\n    let init = { method: 'DELETE' };\n    return ServerConnection.makeRequest(url, init, this.serverSettings).then(\n      response => {\n        if (response.status !== 204) {\n          throw new ServerConnection.ResponseError(response);\n        }\n      }\n    );\n  }\n\n  /**\n   * Get a REST url for a file given a path.\n   */\n  private _getUrl(...args: string[]): string {\n    let parts = args.map(path => URLExt.encodeParts(path));\n    let baseUrl = this.serverSettings.baseUrl;\n    return URLExt.join(baseUrl, this._apiEndpoint, ...parts);\n  }\n\n  private _apiEndpoint: string;\n  private _isDisposed = false;\n  private _fileChanged = new Signal<this, Contents.IChangedArgs>(this);\n}\n\n/**\n * A namespace for ContentsManager statics.\n */\nexport namespace ContentsManager {\n  /**\n   * The options used to initialize a contents manager.\n   */\n  export interface IOptions {\n    /**\n     * The default drive backend for the contents manager.\n     */\n    defaultDrive?: Contents.IDrive;\n\n    /**\n     * The server settings associated with the manager.\n     */\n    serverSettings?: ServerConnection.ISettings;\n  }\n}\n\n/**\n * A namespace for Drive statics.\n */\nexport namespace Drive {\n  /**\n   * The options used to initialize a `Drive`.\n   */\n  export interface IOptions {\n    /**\n     * The name for the `Drive`, which is used in file\n     * paths to disambiguate it from other drives.\n     */\n    name?: string;\n\n    /**\n     * The server settings for the server.\n     */\n    serverSettings?: ServerConnection.ISettings;\n\n    /**\n     * A REST endpoint for drive requests.\n     * If not given, defaults to the Jupyter\n     * REST API given by [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents).\n     */\n    apiEndpoint?: string;\n  }\n}\n\n/**\n * A namespace for module private data.\n */\nnamespace Private {\n  /**\n   * Normalize a file extension to be of the type `'.foo'`.\n   *\n   * Adds a leading dot if not present and converts to lower case.\n   */\n  export function normalizeExtension(extension: string): string {\n    if (extension.length > 0 && extension.indexOf('.') !== 0) {\n      extension = `.${extension}`;\n    }\n    return extension;\n  }\n\n  /**\n   * Normalize a global path. Reduces '..' and '.' parts, and removes\n   * leading slashes from the local part of the path, while retaining\n   * the drive name if it exists.\n   */\n  export function normalize(path: string): string {\n    const parts = path.split(':');\n    if (parts.length === 1) {\n      return PathExt.normalize(path);\n    }\n    return `${parts[0]}:${PathExt.normalize(parts.slice(1).join(':'))}`;\n  }\n}\n"]}